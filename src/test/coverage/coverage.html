
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">antimonyBackend/auth/authManager.go (51.5%)</option>
				
				<option value="file1">antimonyBackend/config/config.go (0.0%)</option>
				
				<option value="file2">antimonyBackend/deployment/clabernetes.provider.go (0.0%)</option>
				
				<option value="file3">antimonyBackend/deployment/containerlab.provider.go (7.6%)</option>
				
				<option value="file4">antimonyBackend/deployment/provider_factory.go (66.7%)</option>
				
				<option value="file5">antimonyBackend/deployment/utils.go (40.0%)</option>
				
				<option value="file6">antimonyBackend/docs/docs.go (0.0%)</option>
				
				<option value="file7">antimonyBackend/domain/collection/collection.handler.go (93.5%)</option>
				
				<option value="file8">antimonyBackend/domain/collection/collection.repository.go (64.1%)</option>
				
				<option value="file9">antimonyBackend/domain/collection/collection.route.go (100.0%)</option>
				
				<option value="file10">antimonyBackend/domain/collection/collection.service.go (88.9%)</option>
				
				<option value="file11">antimonyBackend/domain/device/device.handler.go (100.0%)</option>
				
				<option value="file12">antimonyBackend/domain/device/device.route.go (100.0%)</option>
				
				<option value="file13">antimonyBackend/domain/device/device.service.go (66.7%)</option>
				
				<option value="file14">antimonyBackend/domain/lab/lab.handler.go (80.5%)</option>
				
				<option value="file15">antimonyBackend/domain/lab/lab.repository.go (66.7%)</option>
				
				<option value="file16">antimonyBackend/domain/lab/lab.route.go (100.0%)</option>
				
				<option value="file17">antimonyBackend/domain/lab/lab.service.go (72.4%)</option>
				
				<option value="file18">antimonyBackend/domain/schema/schema.handler.go (66.7%)</option>
				
				<option value="file19">antimonyBackend/domain/schema/schema.route.go (100.0%)</option>
				
				<option value="file20">antimonyBackend/domain/schema/schema.service.go (50.0%)</option>
				
				<option value="file21">antimonyBackend/domain/statusMessage/statusMessage.entity.go (78.6%)</option>
				
				<option value="file22">antimonyBackend/domain/topology/topology.handler.go (89.1%)</option>
				
				<option value="file23">antimonyBackend/domain/topology/topology.repository.go (65.8%)</option>
				
				<option value="file24">antimonyBackend/domain/topology/topology.route.go (100.0%)</option>
				
				<option value="file25">antimonyBackend/domain/topology/topology.service.go (78.0%)</option>
				
				<option value="file26">antimonyBackend/domain/user/user.handler.go (62.9%)</option>
				
				<option value="file27">antimonyBackend/domain/user/user.repository.go (41.7%)</option>
				
				<option value="file28">antimonyBackend/domain/user/user.route.go (100.0%)</option>
				
				<option value="file29">antimonyBackend/domain/user/user.service.go (76.7%)</option>
				
				<option value="file30">antimonyBackend/events/event.go (0.0%)</option>
				
				<option value="file31">antimonyBackend/main.go (0.0%)</option>
				
				<option value="file32">antimonyBackend/socket/namespaceManager.go (22.0%)</option>
				
				<option value="file33">antimonyBackend/socket/socketManager.go (13.9%)</option>
				
				<option value="file34">antimonyBackend/storage/storageManager.go (36.2%)</option>
				
				<option value="file35">antimonyBackend/test/test.go (94.4%)</option>
				
				<option value="file36">antimonyBackend/utils/arguments.go (0.0%)</option>
				
				<option value="file37">antimonyBackend/utils/response.go (75.0%)</option>
				
				<option value="file38">antimonyBackend/utils/schedule.go (50.0%)</option>
				
				<option value="file39">antimonyBackend/utils/utils.go (31.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "antimonyBackend/config"
        "antimonyBackend/utils"
        "context"
        "crypto/rand"
        "fmt"
        "os"
        "slices"
        "time"

        "github.com/charmbracelet/log"
        "github.com/coreos/go-oidc"
        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/oauth2"
)

const NativeUserID = "00000000-0000-0000-0000-00000000000"

type (
        AuthManager interface {
                CreateAuthToken(userId string) (string, error)
                CreateAccessToken(authUser AuthenticatedUser) (string, error)
                AuthenticateUser(tokenString string) (*AuthenticatedUser, error)
                LoginNative(username string, password string) (string, string, error)
                GetAuthCodeURL(stateToken string) (string, error)
                AuthenticateWithCode(authCode string, userSubToIdMapper func(userSub string, userProfile string) (string, error)) (*AuthenticatedUser, error)
                AuthenticatorMiddleware() gin.HandlerFunc
                RefreshAccessToken(authToken string) (string, error)
                RegisterTestUser(authUser AuthenticatedUser) (string, error)

                GetAuthConfig() AuthConfig
        }

        authManager struct {
                config             *config.AntimonyConfig
                authenticatedUsers map[string]*AuthenticatedUser
                oauth2Config       oauth2.Config
                provider           oidc.Provider
                oidcSecret         string
                jwtSecret          []byte
                adminGroups        []string
                authConfig         AuthConfig
                nativeUsername     string
                nativePassword     string
        }

        AuthenticatedUser struct {
                // The UUID of the user
                UserId string
                // List of the names of collections that the user has access to
                Collections []string
                IsAdmin     bool
        }

        AuthConfig struct {
                OpenId OpenIdAuthConfig `json:"openId"`
                Native NativeAuthConfig `json:"native"`
        }

        OpenIdAuthConfig struct {
                Enabled bool `json:"enabled"`
        }

        NativeAuthConfig struct {
                Enabled    bool `json:"enabled"`
                AllowEmpty bool `json:"allowEmpty"`
        }
)

func CreateAuthManager(config *config.AntimonyConfig) AuthManager <span class="cov8" title="1">{
        isOpenIdEnabled := config.Auth.EnableOpenId
        isNativeEnabled := config.Auth.EnableNative

        if !isNativeEnabled &amp;&amp; !isOpenIdEnabled </span><span class="cov0" title="0">{
                log.Fatal("Please enable at least one authentication method.", "native", isNativeEnabled, "openid", isOpenIdEnabled)
        }</span>

        <span class="cov8" title="1">nativeUsername := os.Getenv("SB_NATIVE_USERNAME")
        nativePassword := os.Getenv("SB_NATIVE_PASSWORD")
        emptyCredentials := false

        if isNativeEnabled &amp;&amp; (nativeUsername == "" || nativePassword == "") </span><span class="cov0" title="0">{
                emptyCredentials = true
                log.Warn("Native authentication is enabled but username or password are empty!")
        }</span> else<span class="cov8" title="1"> {
                log.Info("Native authentication is enabled.", "username", nativeUsername)
        }</span>

        <span class="cov8" title="1">authConfig := AuthConfig{
                OpenId: OpenIdAuthConfig{
                        Enabled: isOpenIdEnabled,
                },
                Native: NativeAuthConfig{
                        Enabled:    isNativeEnabled,
                        AllowEmpty: emptyCredentials,
                },
        }

        authManager := &amp;authManager{
                config:             config,
                authenticatedUsers: make(map[string]*AuthenticatedUser),
                adminGroups:        config.Auth.OpenIdAdminGroups,
                jwtSecret:          ([]byte)(rand.Text()),
                oidcSecret:         os.Getenv("SB_OIDC_SECRET"),
                authConfig:         authConfig,
                nativeUsername:     nativeUsername,
                nativePassword:     nativePassword,
        }

        if isNativeEnabled </span><span class="cov8" title="1">{
                authManager.authenticatedUsers[NativeUserID] = &amp;AuthenticatedUser{
                        UserId:      NativeUserID,
                        IsAdmin:     true,
                        Collections: make([]string, 0),
                }
        }</span>

        <span class="cov8" title="1">if isOpenIdEnabled </span><span class="cov0" title="0">{
                provider, err := oidc.NewProvider(context.TODO(), config.Auth.OpenIdIssuer)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to connect to OpenID provider: %s", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        authManager.provider = *provider
                        authManager.oauth2Config = oauth2.Config{
                                ClientID:     config.Auth.OpenIdClientId,
                                ClientSecret: authManager.oidcSecret,
                                RedirectURL:  fmt.Sprintf("%s/users/login/success", config.Auth.OpenIdRedirectHost),
                                Endpoint:     provider.Endpoint(),
                                Scopes:       []string{oidc.ScopeOpenID},
                        }
                }</span>
        }

        <span class="cov8" title="1">return authManager</span>
}

func (m *authManager) RefreshAccessToken(authToken string) (string, error) <span class="cov8" title="1">{
        if authUser, err := m.AuthenticateUser(authToken); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span> else<span class="cov8" title="1"> if newAccessToken, err := m.CreateAccessToken(*authUser); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> {
                return newAccessToken, nil
        }</span>
}

func (m *authManager) AuthenticatorMiddleware() gin.HandlerFunc <span class="cov8" title="1">{
        return func(ctx *gin.Context) </span><span class="cov8" title="1">{
                accessToken, err := ctx.Cookie("accessToken")
                if err != nil </span><span class="cov8" title="1">{
                        ctx.JSON(utils.CreateErrorResponse(utils.ErrorUnauthorized))
                        ctx.Abort()
                        return
                }</span>

                <span class="cov8" title="1">if user, err := m.AuthenticateUser(accessToken); err != nil </span><span class="cov8" title="1">{
                        ctx.JSON(utils.CreateErrorResponse(utils.ErrorTokenInvalid))
                        ctx.Abort()
                        return
                }</span> else<span class="cov8" title="1"> {
                        ctx.Set("authUser", *user)
                        ctx.Next()
                }</span>
        }
}

func (m *authManager) AuthenticateWithCode(authCode string, userSubToIdMapper func(userSub string, userProfile string) (string, error)) (*AuthenticatedUser, error) <span class="cov0" title="0">{
        if !m.authConfig.OpenId.Enabled </span><span class="cov0" title="0">{
                return nil, utils.ErrorOpenIDAuthDisabledError
        }</span>

        <span class="cov0" title="0">ctx := context.TODO()
        token, err := m.oauth2Config.Exchange(ctx, authCode)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[AUTH] OAuth token exchange failed: %s", err.Error())
                return nil, utils.ErrorOpenIDError
        }</span>

        <span class="cov0" title="0">info, err := m.provider.UserInfo(ctx, m.oauth2Config.TokenSource(ctx, token))
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[AUTH] Failed to get oauth userinfo: %s", err.Error())
                return nil, utils.ErrorOpenIDError
        }</span>

        <span class="cov0" title="0">var claims struct {
                Sub     string   `json:"sub"`
                Groups  []string `json:"groups"`
                Profile string   `json:"email"`
        }

        err = info.Claims(&amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                log.Warn("[AUTH] Failed to parse claims from userinfo: %s", err.Error())
                return nil, utils.ErrorOpenIDError
        }</span>

        <span class="cov0" title="0">userSub := claims.Sub
        userGroups := claims.Groups
        userProfile := claims.Profile

        isAdmin := false
        for _, group := range m.adminGroups </span><span class="cov0" title="0">{
                if slices.Contains(userGroups, group) </span><span class="cov0" title="0">{
                        isAdmin = true
                        break</span>
                }
        }

        // Register authenticated user
        <span class="cov0" title="0">userId, err := userSubToIdMapper(userSub, userProfile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">authenticatedUser := &amp;AuthenticatedUser{
                UserId:      userId,
                IsAdmin:     isAdmin,
                Collections: userGroups,
        }
        m.authenticatedUsers[userId] = authenticatedUser

        return authenticatedUser, nil</span>
}
func (m *authManager) GetAuthCodeURL(stateToken string) (string, error) <span class="cov0" title="0">{
        if !m.authConfig.OpenId.Enabled </span><span class="cov0" title="0">{
                return "", utils.ErrorOpenIDAuthDisabledError
        }</span>

        <span class="cov0" title="0">return m.oauth2Config.AuthCodeURL(stateToken), nil</span>
}

func (m *authManager) LoginNative(username string, password string) (string, string, error) <span class="cov8" title="1">{
        if !m.authConfig.Native.Enabled </span><span class="cov0" title="0">{
                return "", "", utils.ErrorNativeAuthDisabledError
        }</span>

        <span class="cov8" title="1">if username == m.nativeUsername &amp;&amp; password == m.nativePassword </span><span class="cov8" title="1">{
                authUser := m.authenticatedUsers[NativeUserID]
                if authToken, err := m.CreateAuthToken(NativeUserID); err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span> else<span class="cov8" title="1"> if accessToken, err := m.CreateAccessToken(*authUser); err != nil </span><span class="cov0" title="0">{
                        return "", "", err
                }</span> else<span class="cov8" title="1"> {
                        return authToken, accessToken, nil
                }</span>
        }
        <span class="cov8" title="1">return "", "", utils.ErrorInvalidCredentials</span>
}

func (m *authManager) AuthenticateUser(tokenString string) (*AuthenticatedUser, error) <span class="cov8" title="1">{
        if token, err := jwt.Parse(tokenString, m.tokenParser); err != nil </span><span class="cov8" title="1">{
                return nil, utils.ErrorTokenInvalid
        }</span> else<span class="cov8" title="1"> if tokenClaims, ok := token.Claims.(jwt.MapClaims); !ok </span><span class="cov0" title="0">{
                return nil, utils.ErrorTokenInvalid
        }</span> else<span class="cov8" title="1"> if userId, ok := tokenClaims["id"]; !ok </span><span class="cov0" title="0">{
                return nil, utils.ErrorTokenInvalid
        }</span> else<span class="cov8" title="1"> if permissions, ok := m.authenticatedUsers[userId.(string)]; !ok </span><span class="cov0" title="0">{
                return nil, utils.ErrorTokenInvalid
        }</span> else<span class="cov8" title="1"> {
                return permissions, nil
        }</span>
}

func (m *authManager) CreateAuthToken(userId string) (string, error) <span class="cov8" title="1">{
        sbToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "id":  userId,
                "nbf": time.Now().Unix(),
                "exp": time.Now().Add(time.Hour * 720).Unix(),
        })

        return sbToken.SignedString(m.jwtSecret)
}</span>

func (m *authManager) CreateAccessToken(authUser AuthenticatedUser) (string, error) <span class="cov8" title="1">{
        sbToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "id":      authUser.UserId,
                "isAdmin": authUser.IsAdmin,
                "nbf":     time.Now().Unix(),
                "exp":     time.Now().Add(time.Minute * 30).Unix(),
        })

        return sbToken.SignedString(m.jwtSecret)
}</span>

func (m *authManager) tokenParser(token *jwt.Token) (interface{}, error) <span class="cov8" title="1">{
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                return nil, utils.ErrorTokenInvalid
        }</span>

        <span class="cov8" title="1">return m.jwtSecret, nil</span>
}

func (m *authManager) RegisterTestUser(user AuthenticatedUser) (string, error) <span class="cov8" title="1">{
        m.authenticatedUsers[user.UserId] = &amp;user
        return user.UserId, nil
}</span>

func (m *authManager) GetAuthConfig() AuthConfig <span class="cov8" title="1">{
        return m.authConfig
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "github.com/charmbracelet/log"
        "gopkg.in/yaml.v3"
        "os"
)

type (
        AntimonyConfig struct {
                Server       ServerConfig     `yaml:"server"`
                Auth         AuthConfig       `yaml:"auth"`
                Shell        ShellConfig      `yaml:"shell"`
                Database     DatabaseConfig   `yaml:"database"`
                FileSystem   FilesystemConfig `yaml:"fileSystem"`
                Containerlab ClabConfig       `yaml:"containerlab"`
        }

        ServerConfig struct {
                Host string `yaml:"host"`
                Port uint   `yaml:"port"`
        }

        AuthConfig struct {
                EnableNative       bool     `yaml:"enableNative"`
                EnableOpenId       bool     `yaml:"enableOpenId"`
                OpenIdIssuer       string   `yaml:"openIdIssuer"`
                OpenIdClientId     string   `yaml:"openIdClientId"`
                OpenIdRedirectHost string   `yaml:"openIdRedirectHost"`
                OpenIdAdminGroups  []string `yaml:"openIdAdminGroups"`
        }

        ShellConfig struct {
                UserLimit int   `yaml:"userLimit"`
                Timeout   int64 `yaml:"timeout"`
        }

        DatabaseConfig struct {
                Host      string `yaml:"host"`
                User      string `yaml:"user"`
                Database  string `yaml:"database"`
                Port      uint   `yaml:"port"`
                LocalFile string `yaml:"localFile"`
        }

        FilesystemConfig struct {
                Storage string `yaml:"storage"`
                Run     string `yaml:"run"`
        }

        ClabConfig struct {
                SchemaUrl      string `yaml:"schemaUrl"`
                SchemaFallback string `yaml:"schemaFallback"`
                DeviceConfig   string `yaml:"deviceConfig"`
        }
)

func Load(fileName string) *AntimonyConfig <span class="cov0" title="0">{
        config := defaultConfig()

        if configData, err := os.ReadFile(fileName); err != nil </span><span class="cov0" title="0">{
                log.Warn("Failed to load configuration file.", "path", fileName)
                data, err := yaml.Marshal(&amp;config)
                err = os.WriteFile(fileName, data, 0755)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to write default configuration file.", "path", fileName)
                }</span>
        } else<span class="cov0" title="0"> if err := yaml.Unmarshal(configData, &amp;config); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to parse configuration file.", "error", err.Error())
        }</span>

        <span class="cov0" title="0">return config</span>
}

func defaultConfig() *AntimonyConfig <span class="cov0" title="0">{
        return &amp;AntimonyConfig{
                Server: ServerConfig{
                        Host: "127.0.0.1",
                        Port: 3000,
                },
                Auth: AuthConfig{
                        EnableNative:       true,
                        EnableOpenId:       false,
                        OpenIdIssuer:       "",
                        OpenIdClientId:     "",
                        OpenIdRedirectHost: "",
                        OpenIdAdminGroups:  make([]string, 0),
                },
                Shell: ShellConfig{
                        UserLimit: 20,
                        Timeout:   1800,
                },
                Database: DatabaseConfig{
                        Host:      "127.0.0.1",
                        User:      "antimony",
                        Database:  "antimony",
                        Port:      5432,
                        LocalFile: "./test.db",
                },
                FileSystem: FilesystemConfig{
                        Storage: "./storage/",
                        Run:     "./run/",
                },
                Containerlab: ClabConfig{
                        SchemaUrl:      "https://raw.githubusercontent.com/srl-labs/containerlab/refs/heads/main/schemas/clab.schema.json",
                        SchemaFallback: "./data/clab.schema.json",
                        DeviceConfig:   "./data/device-config.json",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package deployment

import (
        "context"
        "encoding/json"
        "fmt"
        "gopkg.in/yaml.v3"
        "io"
        "os"
        "os/exec"
)

type TopologyMeta struct {
        Name string `yaml:"name"`
}

type ClabernetesProvider struct{}

func (p *ClabernetesProvider) Deploy(
        ctx context.Context,
        topologyFile string,
        onLog func(string),
) (*string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "sh", "-c",
                "clabverter -t '"+topologyFile+"' --stdout --naming non-prefixed | kubectl apply -f -")
        return runClabCommandSync(cmd, onLog)
}</span>

func (p *ClabernetesProvider) Redeploy(
        ctx context.Context,
        topologyFile string,
        onLog func(string),
) (*string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker", "start", "kind-control-plane")
        return runClabCommandSync(cmd, onLog)
}</span>

func (p *ClabernetesProvider) Destroy(
        ctx context.Context,
        topologyFile string,
        onLog func(string),
) (*string, error) <span class="cov0" title="0">{
        namespace := getTopologyName(topologyFile, onLog)
        cmd := exec.CommandContext(ctx, "kubectl", "delete", "namespace", namespace)
        return runClabCommandSync(cmd, onLog)
}</span>

func (p *ClabernetesProvider) Inspect(
        ctx context.Context,
        topologyFile string,
        onLog func(string),
) (InspectOutput, error) <span class="cov0" title="0">{
        namespace := getTopologyName(topologyFile, onLog)

        cmd := exec.CommandContext(ctx, "kubectl", "get", "pods", "-n", namespace, "-o", "json")
        raw, err := runClabCommandSync(cmd, onLog)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if raw == nil || *raw == "" </span><span class="cov0" title="0">{
                return InspectOutput{}, nil
        }</span>

        <span class="cov0" title="0">var result struct {
                Items []struct {
                        Metadata struct {
                                Name string `json:"name"`
                        } `json:"metadata"`
                        Status struct {
                                PodIP             string `json:"podIP"`
                                Phase             string `json:"phase"`
                                ContainerStatuses []struct {
                                        Image       string `json:"image"`
                                        ContainerID string `json:"containerID"`
                                } `json:"containerStatuses"`
                        } `json:"status"`
                } `json:"items"`
        }
        if err := json.Unmarshal([]byte(*raw), &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse pod list: %w", err)
        }</span>

        <span class="cov0" title="0">var containers []InspectContainer
        for _, pod := range result.Items </span><span class="cov0" title="0">{
                var containerID, image string
                if len(pod.Status.ContainerStatuses) &gt; 0 </span><span class="cov0" title="0">{
                        containerID = pod.Status.ContainerStatuses[0].ContainerID
                        image = pod.Status.ContainerStatuses[0].Image
                }</span>
                <span class="cov0" title="0">containers = append(containers, InspectContainer{
                        Name:        pod.Metadata.Name,
                        ContainerId: containerID,
                        Image:       image,
                        State:       NodeState(pod.Status.Phase),
                        IPv4Address: pod.Status.PodIP,
                        Kind:        "clabernetes",
                        Owner:       namespace,
                })</span>
        }
        <span class="cov0" title="0">return InspectOutput{}, nil</span>
}

func (p *ClabernetesProvider) InspectAll( //not tested
        ctx context.Context,
) (InspectOutput, error) <span class="cov0" title="0">{
        /*cmd := exec.CommandContext(ctx, "kubectl", "get", "topology", "--all-namespaces", "-o", "json")
        if output, err := runClabCommandSync(cmd); err != nil {
                return nil, err
        } else {
                if *output == "" {
                        return &amp;InspectOutput{Containers: []InspectContainer{}}, nil
                }

                var raw map[string]interface{}
                if err := json.Unmarshal([]byte(*output), &amp;raw); err != nil {
                        return nil, err
                }

                return &amp;InspectOutput{Containers: []InspectContainer{}}, nil
        }*/

        return InspectOutput{}, nil
}</span>

func (p *ClabernetesProvider) OpenShell(
        ctx context.Context,
        containerId string,
) (io.ReadWriteCloser, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *ClabernetesProvider) Exec(
        ctx context.Context,
        topologyFile string,
        content string,
        onLog func(string),
        onDone func(*string, error),
) <span class="cov0" title="0">{
        // Optional: probably not needed
        onDone(nil, nil)
}</span>

func (p *ClabernetesProvider) ExecOnNode(
        ctx context.Context,
        topologyFile string,
        content string,
        nodeLabel string,
        onLog func(string),
        onDone func(*string, error),
) <span class="cov0" title="0">{
        namespace := getTopologyName(topologyFile, onLog)
        cmd := exec.CommandContext(ctx, "kubectl", "exec", "-n", namespace, "-i", nodeLabel, "--", content)
        runClabCommand(cmd, onLog, onDone)
}</span>

func (p *ClabernetesProvider) StartNode(ctx context.Context, containerId string) error <span class="cov0" title="0">{
        return nil
}</span>

func (p *ClabernetesProvider) StopNode(ctx context.Context, containerId string) error <span class="cov0" title="0">{
        return nil
}</span>

func (p *ClabernetesProvider) RestartNode(ctx context.Context, containerId string) error <span class="cov0" title="0">{
        return nil
}</span>

func (p *ClabernetesProvider) RegisterListener(ctx context.Context, onUpdate func(containerId string)) error <span class="cov0" title="0">{
        return nil
}</span>

func (p *ClabernetesProvider) StreamContainerLogs(
        ctx context.Context,
        topologyFile string,
        containerID string,
        onLog func(string),
) error <span class="cov0" title="0">{
        namespace := getTopologyName(topologyFile, onLog)
        cmd := exec.CommandContext(ctx, "kubectl", "logs", "-f", containerID, "-n", namespace)
        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">go streamOutput(stdout, onLog)
        return cmd.Wait()</span>
}

func getTopologyName(topologyFile string, onLog func(string)) string <span class="cov0" title="0">{
        content, err := os.ReadFile(topologyFile)
        if err != nil </span><span class="cov0" title="0">{
                onLog(fmt.Sprintf("failed to read topology file: %v", err))
                return ""
        }</span>

        <span class="cov0" title="0">var meta TopologyMeta
        if err := yaml.Unmarshal(content, &amp;meta); err != nil </span><span class="cov0" title="0">{
                onLog(fmt.Sprintf("failed to parse topology file: %v", err))
                return ""
        }</span>

        <span class="cov0" title="0">return "c9s-" + meta.Name</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package deployment

import (
        "context"
        "encoding/json"
        "github.com/charmbracelet/log"
        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/events"
        "github.com/docker/docker/api/types/filters"
        "github.com/docker/docker/client"
        "io"
        "os/exec"
        "time"
)

type ContainerlabProvider struct{}

func (p *ContainerlabProvider) Deploy(
        ctx context.Context,
        topologyFile string,
        onLog func(data string),
) (output *string, err error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "containerlab", "deploy", "-t", topologyFile)
        return runClabCommandSync(cmd, onLog)
}</span>

func (p *ContainerlabProvider) Redeploy(
        ctx context.Context,
        topologyFile string,
        onLog func(data string),
) (output *string, err error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "containerlab", "redeploy", "-t", topologyFile)
        return runClabCommandSync(cmd, onLog)
}</span>

func (p *ContainerlabProvider) Destroy(
        ctx context.Context,
        topologyFile string,
        onLog func(data string),
) (output *string, err error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "containerlab", "destroy", "-t", topologyFile)
        return runClabCommandSync(cmd, onLog)
}</span>

func (p *ContainerlabProvider) Inspect(
        ctx context.Context,
        topologyFile string,
        onLog func(data string),
) (output InspectOutput, err error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "containerlab", "inspect", "-t", topologyFile, "--format", "json")
        rawOutput, err := runClabCommandSync(cmd, onLog)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if *rawOutput == "" </span><span class="cov0" title="0">{
                return InspectOutput{}, nil
        }</span>

        <span class="cov0" title="0">var inspectOutput InspectOutput
        err = json.Unmarshal([]byte(*rawOutput), &amp;inspectOutput)
        return inspectOutput, err</span>
}

func (p *ContainerlabProvider) InspectAll(
        ctx context.Context,
) (InspectOutput, error) <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "containerlab", "inspect", "--all", "--format", "json")
        if output, err := runClabCommandSync(cmd, nil); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                if *output == "" </span><span class="cov0" title="0">{
                        return InspectOutput{}, nil
                }</span>

                <span class="cov8" title="1">var inspectOutput InspectOutput
                err = json.Unmarshal([]byte(*output), &amp;inspectOutput)

                return inspectOutput, err</span>
        }
}

func (p *ContainerlabProvider) Exec(
        ctx context.Context,
        topologyFile string,
        content string,
        onLog func(data string),
        onDone func(output *string, err error),
) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "containerlab", "exec", "-t", topologyFile, "--cmd", content)
        runClabCommand(cmd, onLog, onDone)
}</span>

func (p *ContainerlabProvider) ExecOnNode(
        ctx context.Context,
        topologyFile string,
        content string,
        nodeLabel string,
        onLog func(data string),
        onDone func(output *string, err error),
) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "containerlab", "exec", "-t", topologyFile, "--cmd", content, "--label", nodeLabel)
        runClabCommand(cmd, onLog, onDone)
}</span>

func (p *ContainerlabProvider) OpenShell(
        ctx context.Context,
        containerId string,
) (io.ReadWriteCloser, error) <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">execConfig := container.ExecOptions{
                Cmd:          []string{"/bin/bash"},
                AttachStdin:  true,
                AttachStdout: true,
                AttachStderr: true,
                Tty:          true,
        }

        containerExec, err := cli.ContainerExecCreate(ctx, containerId, execConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">hr, err := cli.ContainerExecAttach(ctx, containerExec.ID, container.ExecAttachOptions{Tty: true})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return hr.Conn, nil</span>
}

func (p *ContainerlabProvider) StartNode(ctx context.Context, containerId string) error <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := cli.ContainerStart(ctx, containerId, container.StartOptions{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *ContainerlabProvider) StopNode(ctx context.Context, containerId string) error <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">timeout := int(10 * time.Second)
        if err := cli.ContainerStop(ctx, containerId, container.StopOptions{Timeout: &amp;timeout}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *ContainerlabProvider) RestartNode(ctx context.Context, containerId string) error <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">timeout := int(10 * time.Second)
        if err := cli.ContainerRestart(ctx, containerId, container.StopOptions{Timeout: &amp;timeout}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *ContainerlabProvider) RegisterListener(ctx context.Context, onUpdate func(containerId string)) error <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">eventFilter := filters.NewArgs()
        eventFilter.Add("type", "container")

        channel, errs := cli.Events(ctx, events.ListOptions{
                Filters: eventFilter,
        })

        for </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-channel:<span class="cov0" title="0">
                        onUpdate(msg.Actor.ID[:12])</span>
                case err := &lt;-errs:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Failed to receive docker events: %s", err.Error())
                                return err
                        }</span>
                }
        }
}

func (p *ContainerlabProvider) StreamContainerLogs(
        ctx context.Context,
        _ string,
        containerId string,
        onLog func(data string),
) error <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(client.FromEnv)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logOptions := container.LogsOptions{
                ShowStdout: true,
                ShowStderr: true,
                Follow:     true,
                Timestamps: false,
                Tail:       "all",
        }

        out, err := cli.ContainerLogs(ctx, containerId, logOptions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go streamOutput(out, onLog)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package deployment

import (
        "os"
)

// GetProvider returns the correct DeploymentProvider implementation based on the DEPLOYMENT_PROVIDER env variable.
func GetProvider() DeploymentProvider <span class="cov8" title="1">{
        switch os.Getenv("DEPLOYMENT_PROVIDER") </span>{
        case "clabernetes":<span class="cov0" title="0">
                return &amp;ClabernetesProvider{}</span>
        default:<span class="cov8" title="1">
                return &amp;ContainerlabProvider{}</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package deployment

import (
        "bufio"
        "bytes"
        "github.com/charmbracelet/log"
        "io"
        "os/exec"
)

func runClabCommandSync(cmd *exec.Cmd, onLog func(string)) (*string, error) <span class="cov8" title="1">{
        var outputBuffer bytes.Buffer
        cmd.Stdout = &amp;outputBuffer

        stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("stderr pipe error: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">go streamOutput(stderr, onLog)

        err = cmd.Wait()
        output := outputBuffer.String()
        return &amp;output, err</span>
}

func runClabCommand(cmd *exec.Cmd, onLog func(string), onDone func(*string, error)) <span class="cov0" title="0">{
        var outputBuffer bytes.Buffer
        cmd.Stdout = &amp;outputBuffer

        stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                onDone(nil, err)
                return
        }</span>

        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                onDone(nil, err)
                return
        }</span>

        <span class="cov0" title="0">go streamOutput(stderr, onLog)

        err = cmd.Wait()
        output := outputBuffer.String()
        onDone(&amp;output, err)</span>
}

func streamOutput(pipe io.Reader, onLog func(data string)) <span class="cov8" title="1">{
        scanner := bufio.NewScanner(pipe)
        for scanner.Scan() </span><span class="cov0" title="0">{
                if onLog != nil </span><span class="cov0" title="0">{
                        onLog(scanner.Text())
                }</span>
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span>{<span class="cov0" title="0">
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Institute for Networking at OST",
            "url": "https://www.ost.ch/en/research-and-consulting-services/computer-science/ins-institute-for-network-and-security",
            "email": "antimony@network.garden"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/collections": {
            "get": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "collections"
                ],
                "summary": "Retrieve all collections the user has access to",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-array_collection_CollectionOut"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "collections"
                ],
                "summary": "Create a new collection",
                "parameters": [
                    {
                        "description": "The collection",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/collection.CollectionIn"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The ID of the newly created collection",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-string"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/collections/{id}": {
            "delete": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "collections"
                ],
                "summary": "Delete an existing collection",
                "parameters": [
                    {
                        "type": "string",
                        "description": "The ID of the collection to edit",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "collections"
                ],
                "summary": "Update an existing collection",
                "parameters": [
                    {
                        "description": "A partial collection with updated values",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/collection.CollectionInPartial"
                        }
                    },
                    {
                        "type": "string",
                        "description": "The ID of the collection to edit",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/devices": {
            "get": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "devices"
                ],
                "summary": "Get all device configurations",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-array_device_DeviceConfig"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "The user doesn't have access to the resource",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/labs": {
            "get": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "labs"
                ],
                "summary": "Get all labs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-array_lab_LabOut"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "labs"
                ],
                "summary": "Create a new lab",
                "parameters": [
                    {
                        "description": "The lab",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/lab.LabIn"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The ID of the newly created lab",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-string"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/labs/:labId": {
            "get": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "labs"
                ],
                "summary": "Get a specific lab by UUIDp",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-lab_LabOut"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "The requested lab was not found.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/labs/{id}": {
            "put": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "labs"
                ],
                "summary": "Update an existing lab",
                "parameters": [
                    {
                        "description": "The lab with updated values",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/lab.LabIn"
                        }
                    },
                    {
                        "type": "string",
                        "description": "The ID of the lab to edit",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "labs"
                ],
                "summary": "Delete an existing lab",
                "parameters": [
                    {
                        "type": "string",
                        "description": "The ID of the lab to delete",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/schema": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "schema"
                ],
                "summary": "Returns the JSON schema to validate topology definitions",
                "responses": {
                    "200": {
                        "description": "The schema as JSON object",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-any"
                        }
                    }
                }
            }
        },
        "/topologies": {
            "get": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "topologies"
                ],
                "summary": "Get all topologies",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-array_topology_TopologyOut"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "topologies"
                ],
                "summary": "Create a new topology",
                "parameters": [
                    {
                        "description": "The topology",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topology.TopologyIn"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The ID of the newly created collection",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-string"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/topologies/{id}": {
            "delete": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "topologies"
                ],
                "summary": "Delete an existing topology",
                "parameters": [
                    {
                        "type": "string",
                        "description": "The ID of the topology to delete",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "topologies"
                ],
                "summary": "Update an existing topology",
                "parameters": [
                    {
                        "description": "The topology with updated values",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topology.TopologyIn"
                        }
                    },
                    {
                        "type": "string",
                        "description": "The ID of the topology to edit",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/topologies/{topologyId}/files": {
            "post": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bindFiles"
                ],
                "summary": "Create a new bind file for a topology",
                "parameters": [
                    {
                        "description": "The bind file",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/topology.BindFileIn"
                        }
                    },
                    {
                        "type": "string",
                        "description": "The ID of the topology the bind file should belong to",
                        "name": "topologyId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "The ID of the newly created file",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-string"
                        }
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/topologies/{topologyId}/files/{bindFileId}": {
            "delete": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bindFiles"
                ],
                "summary": "Delete an existing bind file of a topology",
                "parameters": [
                    {
                        "type": "string",
                        "description": "The ID of the topology the bind file belongs to",
                        "name": "topologyId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "The ID of the bind file to delete",
                        "name": "bindFileId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            },
            "patch": {
                "security": [
                    {
                        "BasicAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "bindFiles"
                ],
                "summary": "Update an existing bind file of a topology",
                "parameters": [
                    {
                        "type": "string",
                        "description": "The ID of the topology the bind file belongs to",
                        "name": "topologyId",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "The ID of the bind file to edit",
                        "name": "bindFileId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "The user isn't authorized"
                    },
                    "403": {
                        "description": "Access to the resource was denied. Details in the request body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "422": {
                        "description": "The request was invalid. Details in the response body.",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "498": {
                        "description": "The provided access token is not valid"
                    }
                }
            }
        },
        "/users/login/config": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Get the server's authentication config",
                "responses": {
                    "200": {
                        "description": "The authentication config of the server",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-auth_AuthConfig"
                        }
                    }
                }
            }
        },
        "/users/login/native": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Authenticate via native login",
                "parameters": [
                    {
                        "description": "The native credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.CredentialsIn"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "The provided credentials were invalid"
                    },
                    "401": {
                        "description": "Authentication via native login is disabled"
                    }
                }
            }
        },
        "/users/login/openid": {
            "get": {
                "consumes": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Authenticate via OpenID provider. Redirects the client to the OpenID provider page.",
                "responses": {
                    "302": {
                        "description": "Found"
                    },
                    "401": {
                        "description": "Authentication via OpenID is disabled"
                    }
                }
            }
        },
        "/users/login/refresh": {
            "get": {
                "tags": [
                    "users"
                ],
                "summary": "Refresh the access token",
                "responses": {
                    "200": {
                        "description": "The authentication config of the server",
                        "schema": {
                            "$ref": "#/definitions/utils.OkResponse-auth_AuthConfig"
                        }
                    },
                    "401": {
                        "description": "The auth token cookie is not set"
                    },
                    "403": {
                        "description": "The provided auth token was invalid"
                    }
                }
            }
        },
        "/users/logout": {
            "post": {
                "tags": [
                    "users"
                ],
                "summary": "Logout and clear all authentication cookies",
                "responses": {
                    "200": {
                        "description": "OK"
                    }
                }
            }
        }
    },
    "definitions": {
        "auth.AuthConfig": {
            "type": "object",
            "properties": {
                "native": {
                    "$ref": "#/definitions/auth.NativeAuthConfig"
                },
                "openId": {
                    "$ref": "#/definitions/auth.OpenIdAuthConfig"
                }
            }
        },
        "auth.NativeAuthConfig": {
            "type": "object",
            "properties": {
                "allowEmpty": {
                    "type": "boolean"
                },
                "enabled": {
                    "type": "boolean"
                }
            }
        },
        "auth.OpenIdAuthConfig": {
            "type": "object",
            "properties": {
                "enabled": {
                    "type": "boolean"
                }
            }
        },
        "collection.CollectionIn": {
            "type": "object",
            "required": [
                "name",
                "publicDeploy",
                "publicWrite"
            ],
            "properties": {
                "name": {
                    "type": "string"
                },
                "publicDeploy": {
                    "type": "boolean"
                },
                "publicWrite": {
                    "type": "boolean"
                }
            }
        },
        "collection.CollectionInPartial": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "publicDeploy": {
                    "type": "boolean"
                },
                "publicWrite": {
                    "type": "boolean"
                }
            }
        },
        "collection.CollectionOut": {
            "type": "object",
            "properties": {
                "creator": {
                    "$ref": "#/definitions/user.UserOut"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "publicDeploy": {
                    "type": "boolean"
                },
                "publicWrite": {
                    "type": "boolean"
                }
            }
        },
        "deployment.NodeState": {
            "type": "string",
            "enum": [
                "running"
            ],
            "x-enum-varnames": [
                "running"
            ]
        },
        "device.DeviceConfig": {
            "type": "object",
            "properties": {
                "interfacePattern": {
                    "type": "string"
                },
                "interfaceStart": {
                    "type": "integer"
                },
                "kind": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "lab.InstanceNode": {
            "type": "object",
            "properties": {
                "containerId": {
                    "type": "string"
                },
                "containerName": {
                    "type": "string"
                },
                "ipv4": {
                    "type": "string"
                },
                "ipv6": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "port": {
                    "type": "integer"
                },
                "state": {
                    "$ref": "#/definitions/deployment.NodeState"
                },
                "user": {
                    "type": "string"
                },
                "webSSH": {
                    "type": "string"
                }
            }
        },
        "lab.InstanceOut": {
            "type": "object",
            "properties": {
                "deployed": {
                    "type": "string"
                },
                "edgesharkLink": {
                    "type": "string"
                },
                "latestStateChange": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "nodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/lab.InstanceNode"
                    }
                },
                "recovered": {
                    "type": "boolean"
                },
                "state": {
                    "$ref": "#/definitions/lab.InstanceState"
                }
            }
        },
        "lab.InstanceState": {
            "type": "integer",
            "enum": [
                0,
                1,
                2,
                3,
                -1,
                -2
            ],
            "x-enum-varnames": [
                "deploying",
                "running",
                "stopping",
                "failed",
                "inactive",
                "scheduled"
            ]
        },
        "lab.LabIn": {
            "type": "object",
            "required": [
                "endTime",
                "name",
                "startTime",
                "topologyId"
            ],
            "properties": {
                "endTime": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "startTime": {
                    "type": "string"
                },
                "topologyId": {
                    "type": "string"
                }
            }
        },
        "lab.LabOut": {
            "type": "object",
            "properties": {
                "collectionId": {
                    "type": "string"
                },
                "creator": {
                    "$ref": "#/definitions/user.UserOut"
                },
                "endTime": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "instance": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/lab.InstanceOut"
                        }
                    ],
                    "x-nullable": true
                },
                "instanceName": {
                    "type": "string",
                    "x-nullable": true
                },
                "name": {
                    "type": "string"
                },
                "startTime": {
                    "type": "string"
                },
                "topologyDefinition": {
                    "type": "string"
                },
                "topologyId": {
                    "type": "string"
                }
            }
        },
        "topology.BindFileIn": {
            "type": "object",
            "required": [
                "content",
                "filePath"
            ],
            "properties": {
                "content": {
                    "type": "string"
                },
                "filePath": {
                    "type": "string"
                }
            }
        },
        "topology.BindFileOut": {
            "type": "object",
            "properties": {
                "content": {
                    "type": "string"
                },
                "filePath": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "topologyId": {
                    "type": "string"
                }
            }
        },
        "topology.TopologyIn": {
            "type": "object",
            "required": [
                "collectionId",
                "definition",
                "syncUrl"
            ],
            "properties": {
                "collectionId": {
                    "type": "string"
                },
                "definition": {
                    "type": "string"
                },
                "syncUrl": {
                    "type": "string"
                }
            }
        },
        "topology.TopologyOut": {
            "type": "object",
            "properties": {
                "bindFiles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/topology.BindFileOut"
                    }
                },
                "collectionId": {
                    "type": "string"
                },
                "creator": {
                    "$ref": "#/definitions/user.UserOut"
                },
                "definition": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "lastDeployFailed": {
                    "type": "boolean"
                },
                "syncUrl": {
                    "type": "string"
                }
            }
        },
        "user.CredentialsIn": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "user.UserOut": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "utils.ErrorResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "utils.OkResponse-any": {
            "type": "object",
            "properties": {
                "payload": {}
            }
        },
        "utils.OkResponse-array_collection_CollectionOut": {
            "type": "object",
            "properties": {
                "payload": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/collection.CollectionOut"
                    }
                }
            }
        },
        "utils.OkResponse-array_device_DeviceConfig": {
            "type": "object",
            "properties": {
                "payload": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/device.DeviceConfig"
                    }
                }
            }
        },
        "utils.OkResponse-array_lab_LabOut": {
            "type": "object",
            "properties": {
                "payload": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/lab.LabOut"
                    }
                }
            }
        },
        "utils.OkResponse-array_topology_TopologyOut": {
            "type": "object",
            "properties": {
                "payload": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/topology.TopologyOut"
                    }
                }
            }
        },
        "utils.OkResponse-auth_AuthConfig": {
            "type": "object",
            "properties": {
                "payload": {
                    "$ref": "#/definitions/auth.AuthConfig"
                }
            }
        },
        "utils.OkResponse-lab_LabOut": {
            "type": "object",
            "properties": {
                "payload": {
                    "$ref": "#/definitions/lab.LabOut"
                }
            }
        },
        "utils.OkResponse-string": {
            "type": "object",
            "properties": {
                "payload": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "BasicAuth": {
            "type": "basic"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "/api/v1",
        Schemes:          []string{},
        Title:            "Antimony API",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package collection

import (
        "antimonyBackend/auth"
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
)

type (
        Handler interface {
                Get(ctx *gin.Context)
                Create(ctx *gin.Context)
                Update(ctx *gin.Context)
                Delete(ctx *gin.Context)
        }

        collectionHandler struct {
                collectionService Service
        }
)

func CreateHandler(collectionService Service) Handler <span class="cov8" title="1">{
        return &amp;collectionHandler{
                collectionService: collectionService,
        }
}</span>

// @Summary        Retrieve all collections the user has access to
// @Produce        json
// @Tags                collections
// @Security        BasicAuth
// @Success        200        {object}        utils.OkResponse[[]collection.CollectionOut]
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Router                /collections [get]
func (h *collectionHandler) Get(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        result, err := h.collectionService.Get(ctx, authUser)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Create a new collection
// @Accept                json
// @Produce        json
// @Tags                collections
// @Security        BasicAuth
// @Success        200                {object}        utils.OkResponse[string]        "The ID of the newly created collection"
// @Failure        401                {object}        nil                                                        "The user isn't authorized"
// @Failure        498                {object}        nil                                                        "The provided access token is not valid"
// @Failure        403                {object}        utils.ErrorResponse                        "Access to the resource was denied. Details in the request body."
// @Param                request        body                collection.CollectionIn                true        "The collection"
// @Router                /collections [post]
func (h *collectionHandler) Create(ctx *gin.Context) <span class="cov8" title="1">{
        payload := CollectionIn{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        result, err := h.collectionService.Create(ctx, payload, authUser)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Update an existing collection
// @Accept                json
// @Produce        json
// @Tags                collections
// @Security        BasicAuth
// @Success        200                {object}        nil
// @Failure        401                {object}        nil                                                "The user isn't authorized"
// @Failure        498                {object}        nil                                                "The provided access token is not valid"
// @Failure        403                {object}        utils.ErrorResponse                "Access to the resource was denied. Details in the request body."
// @Failure        422                {object}        utils.ErrorResponse                "The request was invalid. Details in the response body."
// @Param                request        body                collection.CollectionInPartial        true        "A partial collection with updated values"
// @Param                id                path                string                                        true        "The ID of the collection to edit"
// @Router                /collections/{id} [patch]
func (h *collectionHandler) Update(ctx *gin.Context) <span class="cov8" title="1">{
        payload := CollectionInPartial{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.collectionService.Update(ctx, payload, ctx.Param("collectionId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}

// @Summary        Delete an existing collection
// @Produce        json
// @Tags                collections
// @Security        BasicAuth
// @Success        200        {object}        nil
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422        {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                id        path                string                                true        "The ID of the collection to edit"
// @Router                /collections/{id} [delete]
func (h *collectionHandler) Delete(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)

        if err := h.collectionService.Delete(ctx, ctx.Param("collectionId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package collection

import (
        "antimonyBackend/utils"
        "context"
        "github.com/charmbracelet/log"
        "gorm.io/gorm"
)

type (
        Repository interface {
                GetAll(ctx context.Context) ([]Collection, error)
                GetByUuid(ctx context.Context, collectionId string) (*Collection, error)
                GetByNames(ctx context.Context, collectionNames []string) ([]Collection, error)
                DoesNameExist(ctx context.Context, collectionName string) (bool, error)

                Create(ctx context.Context, collection *Collection) error
                Update(ctx context.Context, collection *Collection) error
                Delete(ctx context.Context, collection *Collection) error
        }

        collectionRepository struct {
                db *gorm.DB
        }
)

func CreateRepository(db *gorm.DB) Repository <span class="cov8" title="1">{
        return &amp;collectionRepository{
                db: db,
        }
}</span>

func (r *collectionRepository) GetAll(ctx context.Context) ([]Collection, error) <span class="cov8" title="1">{
        var collections []Collection
        result := r.db.WithContext(ctx).
                Preload("Creator").
                Find(&amp;collections)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch all collections. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return collections, nil</span>
}

func (r *collectionRepository) GetByUuid(ctx context.Context, collectionId string) (*Collection, error) <span class="cov8" title="1">{
        var collection Collection
        result := r.db.WithContext(ctx).
                Preload("Creator").
                Where("uuid = ?", collectionId).
                Find(&amp;collection)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return nil, utils.ErrorUuidNotFound
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to get collection by UUID. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return &amp;collection, result.Error</span>
}

func (r *collectionRepository) GetByNames(ctx context.Context, collectionNames []string) ([]Collection, error) <span class="cov8" title="1">{
        var collections []Collection
        result := r.db.WithContext(ctx).
                Preload("Creator").
                Where("Name IN ?", collectionNames).
                Find(&amp;collections)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch collections by names. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return collections, nil</span>
}

func (r *collectionRepository) DoesNameExist(ctx context.Context, collectionName string) (bool, error) <span class="cov8" title="1">{
        var collection Collection
        result := r.db.WithContext(ctx).
                Where("name = ? AND deleted_at IS NULL", collectionName).
                Limit(1).
                Find(&amp;collection)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to check if collection name exists. Error: %s", result.Error.Error())
                return false, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return result.RowsAffected &gt; 0, nil</span>
}

func (r *collectionRepository) Create(ctx context.Context, collection *Collection) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Create(collection).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to create collection. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *collectionRepository) Update(ctx context.Context, collection *Collection) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Save(collection).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to update collection. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *collectionRepository) Delete(ctx context.Context, collection *Collection) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Delete(collection).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to delete collection. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package collection

import (
        "antimonyBackend/auth"
        "github.com/gin-gonic/gin"
)

func RegisterRoutes(route *gin.Engine, handler Handler, authManager auth.AuthManager) <span class="cov8" title="1">{
        routes := route.Group("/collections", authManager.AuthenticatorMiddleware())
        </span><span class="cov8" title="1">{
                routes.GET("", handler.Get)
                routes.POST("", handler.Create)
                routes.PATCH("/:collectionId", handler.Update)
                routes.DELETE("/:collectionId", handler.Delete)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package collection

import (
        "antimonyBackend/auth"
        "antimonyBackend/domain/user"
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
)

type (
        Service interface {
                Get(ctx *gin.Context, authUser auth.AuthenticatedUser) ([]CollectionOut, error)
                Create(ctx *gin.Context, req CollectionIn, authUser auth.AuthenticatedUser) (string, error)
                Update(ctx *gin.Context, req CollectionInPartial, collectionId string, authUser auth.AuthenticatedUser) error
                Delete(ctx *gin.Context, collectionId string, authUser auth.AuthenticatedUser) error
        }

        collectionService struct {
                userRepo       user.Repository
                collectionRepo Repository
        }
)

func CreateService(collectionRepo Repository, userRepo user.Repository) Service <span class="cov8" title="1">{
        return &amp;collectionService{
                userRepo:       userRepo,
                collectionRepo: collectionRepo,
        }
}</span>

func (u *collectionService) Get(ctx *gin.Context, authUser auth.AuthenticatedUser) ([]CollectionOut, error) <span class="cov8" title="1">{
        var (
                collections []Collection
                err         error
        )

        if authUser.IsAdmin </span><span class="cov8" title="1">{
                collections, err = u.collectionRepo.GetAll(ctx)
        }</span> else<span class="cov8" title="1"> {
                collections, err = u.collectionRepo.GetByNames(ctx, authUser.Collections)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]CollectionOut, len(collections))
        for i, collection := range collections </span><span class="cov8" title="1">{
                result[i] = CollectionOut{
                        ID:           collection.UUID,
                        Name:         collection.Name,
                        PublicWrite:  collection.PublicWrite,
                        PublicDeploy: collection.PublicDeploy,
                        Creator:      u.userRepo.UserToOut(collection.Creator),
                }
        }</span>

        <span class="cov8" title="1">return result, err</span>
}

func (u *collectionService) Create(ctx *gin.Context, req CollectionIn, authUser auth.AuthenticatedUser) (string, error) <span class="cov8" title="1">{
        // Deny request if the user is not an admin
        if !authUser.IsAdmin </span><span class="cov8" title="1">{
                return "", utils.ErrorNoPermissionToCreateCollections
        }</span>

        // Don't allow duplicate collection names
        <span class="cov8" title="1">if nameExists, err := u.collectionRepo.DoesNameExist(ctx, *req.Name); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> if nameExists </span><span class="cov0" title="0">{
                return "", utils.ErrorCollectionExists
        }</span>

        <span class="cov8" title="1">newUuid := utils.GenerateUuid()

        creator, err := u.userRepo.GetByUuid(ctx, authUser.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return newUuid, u.collectionRepo.Create(ctx, &amp;Collection{
                UUID:         newUuid,
                Name:         *req.Name,
                PublicWrite:  *req.PublicWrite,
                PublicDeploy: *req.PublicDeploy,
                Creator:      *creator,
        })</span>
}

func (u *collectionService) Update(ctx *gin.Context, req CollectionInPartial, collectionId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        collection, err := u.collectionRepo.GetByUuid(ctx, collectionId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested topology or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != collection.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToCollection
        }</span>

        <span class="cov8" title="1">if req.Name != nil </span><span class="cov8" title="1">{
                // Don't allow duplicate collection names
                if collection.Name != *req.Name </span><span class="cov8" title="1">{
                        if nameExists, err := u.collectionRepo.DoesNameExist(ctx, *req.Name); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span> else<span class="cov8" title="1"> if nameExists </span><span class="cov8" title="1">{
                                return utils.ErrorCollectionExists
                        }</span>
                }

                <span class="cov8" title="1">collection.Name = *req.Name</span>
        }

        <span class="cov8" title="1">if req.PublicWrite != nil </span><span class="cov8" title="1">{
                collection.PublicWrite = *req.PublicWrite
        }</span>

        <span class="cov8" title="1">if req.PublicDeploy != nil </span><span class="cov8" title="1">{
                collection.PublicDeploy = *req.PublicDeploy
        }</span>

        <span class="cov8" title="1">return u.collectionRepo.Update(ctx, collection)</span>
}

func (u *collectionService) Delete(ctx *gin.Context, collectionId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        collection, err := u.collectionRepo.GetByUuid(ctx, collectionId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested topology or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != collection.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToCollection
        }</span>

        <span class="cov8" title="1">return u.collectionRepo.Delete(ctx, collection)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package device

import (
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
)

type (
        Handler interface {
                Get(ctx *gin.Context)
        }

        deviceHandler struct {
                deviceService Service
        }
)

func CreateHandler(deviceService Service) Handler <span class="cov8" title="1">{
        return &amp;deviceHandler{
                deviceService: deviceService,
        }
}</span>

//        @Summary        Get all device configurations
//        @Produce        json
//        @Tags                devices
//        @Security        BasicAuth
//        @Success        200        {object}        utils.OkResponse[[]device.DeviceConfig]
//        @Failure        401        {object}        nil                                                        "The user isn't authorized"
//        @Failure        498        {object}        nil                                                        "The provided access token is not valid"
//        @Failure        403        {object}        utils.ErrorResponse[string]        "The user doesn't have access to the resource"
//        @Router                /devices [get]
func (h *deviceHandler) Get(ctx *gin.Context) <span class="cov8" title="1">{
        ctx.JSON(utils.CreateOkResponse(h.deviceService.Get()))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package device

import (
        "antimonyBackend/auth"
        "github.com/gin-gonic/gin"
)

func RegisterRoutes(route *gin.Engine, handler Handler, authManager auth.AuthManager) <span class="cov8" title="1">{
        routes := route.Group("/devices", authManager.AuthenticatorMiddleware())
        </span><span class="cov8" title="1">{
                routes.GET("", handler.Get)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package device

import (
        "antimonyBackend/config"
        "encoding/json"
        "github.com/charmbracelet/log"
        "io"
        "os"
)

type (
        Service interface {
                Get() []DeviceConfig
        }

        deviceService struct {
                devices []DeviceConfig
        }
)

func CreateService(config *config.AntimonyConfig) Service <span class="cov8" title="1">{
        deviceConfig := make([]DeviceConfig, 0)

        if deviceConfigFile, err := os.Open(config.Containerlab.DeviceConfig); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to open device config file", "file", config.Containerlab.DeviceConfig)
        }</span> else<span class="cov8" title="1"> if fileData, err := io.ReadAll(deviceConfigFile); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to read device config file", "file", config.Containerlab.DeviceConfig, "err", err.Error())
        }</span> else<span class="cov8" title="1"> if err := json.Unmarshal(fileData, &amp;deviceConfig); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to parse device config file", "file", config.Containerlab.DeviceConfig, "err", err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;deviceService{
                devices: deviceConfig,
        }</span>
}

func (s *deviceService) Get() []DeviceConfig <span class="cov8" title="1">{
        return s.devices
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package lab

import (
        "antimonyBackend/auth"
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
)

type (
        Handler interface {
                Get(ctx *gin.Context)
                GetByUuid(ctx *gin.Context)
                Create(ctx *gin.Context)
                Update(ctx *gin.Context)
                Delete(ctx *gin.Context)
        }

        labHandler struct {
                labService Service
        }
)

func CreateHandler(labService Service) Handler <span class="cov8" title="1">{
        return &amp;labHandler{
                labService: labService,
        }
}</span>

// @Summary        Get all labs
// @Produce        json
// @Tags                labs
// @Security        BasicAuth
// @Success        200        {object}        utils.OkResponse[[]lab.LabOut]
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Router                /labs [get]
func (h *labHandler) Get(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        var labFilter LabFilter
        if err := ctx.BindQuery(&amp;labFilter); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">result, err := h.labService.Get(ctx, labFilter, authUser)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Get a specific lab by UUIDp
// @Produce        json
// @Tags                labs
// @Security        BasicAuth
// @Success        200        {object}        utils.OkResponse[LabOut]
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        404        {object}        utils.ErrorResponse        "The requested lab was not found."
// @Router                /labs/:labId [get]
func (h *labHandler) GetByUuid(ctx *gin.Context) <span class="cov0" title="0">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)

        result, err := h.labService.GetByUuid(ctx, ctx.Param("labId"), authUser)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Create a new lab
// @Accept                json
// @Produce        json
// @Tags                labs
// @Security        BasicAuth
// @Success        200                {object}        utils.OkResponse[string]        "The ID of the newly created lab"
// @Failure        401                {object}        nil                                                        "The user isn't authorized"
// @Failure        498                {object}        nil                                                        "The provided access token is not valid"
// @Failure        403                {object}        utils.ErrorResponse                        "Access to the resource was denied. Details in the request body."
// @Param                request        body                lab.LabIn                                        true        "The lab"
// @Router                /labs [post]
func (h *labHandler) Create(ctx *gin.Context) <span class="cov8" title="1">{
        payload := LabIn{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        result, err := h.labService.Create(ctx, payload, authUser)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Update an existing lab
// @Accept                json
// @Produce        json
// @Tags                labs
// @Security        BasicAuth
// @Success        200                {object}        nil
// @Failure        401                {object}        nil                                        "The user isn't authorized"
// @Failure        498                {object}        nil                                        "The provided access token is not valid"
// @Failure        403                {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422                {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                request        body                lab.LabIn                        true        "The lab with updated values"
// @Param                id                path                string                                true        "The ID of the lab to edit"
// @Router                /labs/{id} [put]
func (h *labHandler) Update(ctx *gin.Context) <span class="cov8" title="1">{
        payload := LabInPartial{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.labService.Update(ctx, payload, ctx.Param("labId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}

// @Summary        Delete an existing lab
// @Produce        json
// @Tags                labs
// @Security        BasicAuth
// @Success        200        {object}        nil
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422        {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                id        path                string                                true        "The ID of the lab to delete"
// @Router                /labs/{id} [delete]
func (h *labHandler) Delete(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.labService.Delete(ctx, ctx.Param("labId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package lab

import (
        "antimonyBackend/utils"
        "context"
        "github.com/charmbracelet/log"
        "gorm.io/gorm"
)

type (
        Repository interface {
                GetAll(ctx context.Context, labFilter *LabFilter) ([]Lab, error)
                GetByUuid(ctx context.Context, labId string) (*Lab, error)

                Create(ctx context.Context, lab *Lab) error
                Update(ctx context.Context, lab *Lab) error
                Delete(ctx context.Context, lab *Lab) error
        }

        labRepository struct {
                db *gorm.DB
        }
)

func CreateRepository(db *gorm.DB) Repository <span class="cov8" title="1">{
        return &amp;labRepository{
                db: db,
        }
}</span>

func (r *labRepository) GetAll(ctx context.Context, labFilter *LabFilter) ([]Lab, error) <span class="cov8" title="1">{
        var labs []Lab
        query := r.db.WithContext(ctx).
                Preload("Topology.Collection").
                Preload("Creator").
                Order("labs.start_time")

        if labFilter != nil </span><span class="cov8" title="1">{
                if labFilter.StartDate != nil </span><span class="cov0" title="0">{
                        query = query.Where("labs.start_time &gt;= ?", labFilter.StartDate)
                }</span>
                <span class="cov8" title="1">if labFilter.EndDate != nil </span><span class="cov0" title="0">{
                        query = query.Where("labs.end_time &lt;= ?", labFilter.EndDate)
                }</span>
                <span class="cov8" title="1">if len(labFilter.CollectionFilter) &gt; 0 </span><span class="cov0" title="0">{
                        query = query.
                                Joins("JOIN topologies ON topologies.id = labs.topology_id").
                                Joins("JOIN collections ON collections.id = topologies.collection_id").
                                Where("collections.uuid IN ?", labFilter.CollectionFilter)
                }</span>
                <span class="cov8" title="1">if labFilter.SearchQuery != nil &amp;&amp; len(*labFilter.SearchQuery) &gt; 0 </span><span class="cov8" title="1">{
                        matchQuery := "%" + *labFilter.SearchQuery + "%"
                        query = query.
                                Joins("JOIN topologies ON topologies.id = labs.topology_id").
                                Joins("JOIN collections ON collections.id = topologies.collection_id").
                                Where(
                                        "labs.name LIKE ? OR topologies.name LIKE ? OR collections.name LIKE ?",
                                        matchQuery, matchQuery, matchQuery,
                                )
                }</span>
                <span class="cov8" title="1">query = query.Limit(labFilter.Limit).Offset(labFilter.Offset)</span>
        }
        <span class="cov8" title="1">result := query.Find(&amp;labs)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch all labs. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return labs, nil</span>
}

func (r *labRepository) GetByUuid(ctx context.Context, labId string) (*Lab, error) <span class="cov8" title="1">{
        var lab Lab
        result := r.db.WithContext(ctx).
                Preload("Topology.Collection").
                Preload("Creator").
                Where("uuid = ?", labId).
                Find(&amp;lab)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return nil, utils.ErrorUuidNotFound
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch lab by UUID. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return &amp;lab, nil</span>
}

func (r *labRepository) Create(ctx context.Context, lab *Lab) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Create(lab).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to create lab. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *labRepository) Update(ctx context.Context, lab *Lab) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Save(lab).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to update lab. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *labRepository) Delete(ctx context.Context, lab *Lab) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Delete(lab).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to delete lab. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package lab

import (
        "antimonyBackend/auth"
        "github.com/gin-gonic/gin"
)

func RegisterRoutes(route *gin.Engine, handler Handler, authManager auth.AuthManager) <span class="cov8" title="1">{
        routes := route.Group("/labs", authManager.AuthenticatorMiddleware())
        </span><span class="cov8" title="1">{
                routes.GET("", handler.Get)
                routes.GET("/:labId", handler.GetByUuid)
                routes.POST("", handler.Create)
                routes.PATCH("/:labId", handler.Update)
                routes.DELETE("/:labId", handler.Delete)
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package lab

import (
        "antimonyBackend/auth"
        "antimonyBackend/config"
        "antimonyBackend/deployment"
        "antimonyBackend/domain/statusMessage"
        "antimonyBackend/domain/topology"
        "antimonyBackend/domain/user"
        "antimonyBackend/socket"
        "antimonyBackend/storage"
        "antimonyBackend/utils"
        "context"
        "fmt"
        "github.com/charmbracelet/log"
        "github.com/gin-gonic/gin"
        "github.com/samber/lo"
        "gopkg.in/yaml.v3"
        "io"
        "regexp"
        "slices"
        "strings"
        "sync"
        "time"
)

const ShellTimeout = 60

type (
        Service interface {
                Get(ctx *gin.Context, labFilter LabFilter, authUser auth.AuthenticatedUser) ([]LabOut, error)
                GetByUuid(ctx *gin.Context, labId string, authUser auth.AuthenticatedUser) (*LabOut, error)
                Create(ctx *gin.Context, req LabIn, authUser auth.AuthenticatedUser) (string, error)
                Update(ctx *gin.Context, req LabInPartial, labId string, authUser auth.AuthenticatedUser) error
                Delete(ctx *gin.Context, labId string, authUser auth.AuthenticatedUser) error

                // RunScheduler Starts looping through all scheduled labs and waits to deploy them
                RunScheduler()

                RunShellManager()

                ListenToProviderEvents()
        }

        labService struct {
                config                 *config.AntimonyConfig
                labDeploymentSchedule  utils.Schedule[Lab]
                labDestructionSchedule utils.Schedule[Lab]

                // Map of currently active instances indexed by lab ID.
                // The instances can be in any of the real states.
                instances      map[string]*Instance
                instancesMutex sync.Mutex

                openShells      map[string]*ShellConfig
                openShellsMutex sync.Mutex

                nodeLabMap      map[string]*Lab
                nodeLabMapMutex sync.Mutex

                labRepo                Repository
                userRepo               user.Repository
                topologyRepo           topology.Repository
                topologyService        topology.Service
                storageManager         storage.StorageManager
                deploymentProvider     deployment.DeploymentProvider
                socketManager          socket.SocketManager
                labUpdatesNamespace    socket.OutputNamespace[string]
                labCommandsNamespace   socket.InputNamespace[LabCommandData]
                shellCommandsNamespace socket.OutputNamespace[ShellCommandData]
                statusMessageNamespace socket.OutputNamespace[statusMessage.StatusMessage]
        }

        ShellConfig struct {
                Owner            *auth.AuthenticatedUser
                LabId            string
                Node             string
                Connection       io.ReadWriteCloser
                ConnectionCancel context.CancelFunc
                LastInteraction  int64
                DataNamespace    socket.IONamespace[string, string]
        }
)

func CreateService(
        config *config.AntimonyConfig,
        labRepo Repository,
        userRepo user.Repository,
        topologyRepo topology.Repository,
        topologyService topology.Service,
        storageManager storage.StorageManager,
        socketManager socket.SocketManager,
        statusMessageNamespace socket.OutputNamespace[statusMessage.StatusMessage],
) Service <span class="cov8" title="1">{
        deploymentSchedule := utils.CreateSchedule[Lab](
                func(lab Lab) string </span><span class="cov8" title="1">{
                        return lab.UUID
                }</span>,
                func(lab Lab) *time.Time <span class="cov8" title="1">{
                        return &amp;lab.StartTime
                }</span>,
        )

        <span class="cov8" title="1">destructionSchedule := utils.CreateSchedule[Lab](
                func(lab Lab) string </span><span class="cov8" title="1">{
                        return lab.UUID
                }</span>,
                func(lab Lab) *time.Time <span class="cov8" title="1">{
                        return lab.EndTime
                }</span>,
        )

        <span class="cov8" title="1">labService := &amp;labService{
                config:                 config,
                labRepo:                labRepo,
                userRepo:               userRepo,
                topologyRepo:           topologyRepo,
                topologyService:        topologyService,
                labDeploymentSchedule:  deploymentSchedule,
                labDestructionSchedule: destructionSchedule,
                openShells:             make(map[string]*ShellConfig),
                openShellsMutex:        sync.Mutex{},
                instances:              make(map[string]*Instance),
                instancesMutex:         sync.Mutex{},
                storageManager:         storageManager,
                deploymentProvider:     deployment.GetProvider(),
                socketManager:          socketManager,
                statusMessageNamespace: statusMessageNamespace,
        }
        labService.labUpdatesNamespace = socket.CreateOutputNamespace[string](
                socketManager, false, false, nil, "lab-updates",
        )
        labService.labCommandsNamespace = socket.CreateInputNamespace[LabCommandData](
                socketManager, false, false, labService.handleLabCommand, nil, "lab-commands",
        )
        labService.shellCommandsNamespace = socket.CreateOutputNamespace[ShellCommandData](
                socketManager, false, false, nil, "shell-commands",
        )

        labService.reviveLabs()
        labService.labUpdatesNamespace.Send("")

        return labService</span>
}

func (s *labService) RunScheduler() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                if lab := s.labDeploymentSchedule.TryPop(); lab != nil </span><span class="cov8" title="1">{
                        go func() </span><span class="cov8" title="1">{
                                _ = s.deployLab(lab)
                        }</span>()

                        // Schedule the destruction of the lab
                        <span class="cov8" title="1">s.labDestructionSchedule.Schedule(lab)</span>
                }

                <span class="cov8" title="1">if lab := s.labDestructionSchedule.TryPop(); lab != nil </span><span class="cov0" title="0">{
                        go func() </span><span class="cov0" title="0">{
                                _ = s.destroyLab(lab, s.instances[lab.UUID])
                        }</span>()
                }

                <span class="cov8" title="1">time.Sleep(5 * time.Second)</span>
        }
}

func (s *labService) RunShellManager() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                s.openShellsMutex.Lock()
                for shellId, shell := range s.openShells </span><span class="cov0" title="0">{
                        log.Infof("shell timeout: %d", time.Now().Unix()-shell.LastInteraction)
                        if time.Now().Unix()-shell.LastInteraction &gt; s.config.Shell.Timeout </span><span class="cov0" title="0">{
                                if err := s.closeShell(shellId, shell, "shell was inactive for too long"); err != nil </span><span class="cov0" title="0">{
                                        log.Errorf("Failed to close shell: %s", err.Error())
                                }</span>

                                <span class="cov0" title="0">delete(s.openShells, shellId)</span>
                        }
                }
                <span class="cov0" title="0">s.openShellsMutex.Unlock()

                time.Sleep(5 * time.Second)</span>
        }
}

func (s *labService) ListenToProviderEvents() <span class="cov0" title="0">{
        ctx := context.Background()

        err := s.deploymentProvider.RegisterListener(ctx, func(containerId string) </span><span class="cov0" title="0">{
                var targetLabId *string

                s.instancesMutex.Lock()
                for labId, instance := range s.instances </span><span class="cov0" title="0">{
                        _, hasMatched := lo.Find(instance.Nodes, func(item InstanceNode) bool </span><span class="cov0" title="0">{
                                return item.ContainerId == containerId
                        }</span>)

                        <span class="cov0" title="0">if hasMatched </span><span class="cov0" title="0">{
                                targetLabId = &amp;labId
                                break</span>
                        }
                }
                <span class="cov0" title="0">s.instancesMutex.Unlock()

                if targetLabId != nil </span><span class="cov0" title="0">{
                        s.labUpdatesNamespace.Send(*targetLabId)
                }</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func (s *labService) Get(ctx *gin.Context, labFilter LabFilter, authUser auth.AuthenticatedUser) ([]LabOut, error) <span class="cov8" title="1">{
        var (
                labs []Lab
                err  error
        )

        // If the user isn't admin, restrict collection filter to accessible collections
        if !authUser.IsAdmin </span><span class="cov8" title="1">{
                labFilter.CollectionFilter = lo.Intersect(labFilter.CollectionFilter, authUser.Collections)
        }</span>

        <span class="cov8" title="1">if labs, err = s.labRepo.GetAll(ctx, &amp;labFilter); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hasStateFilter := len(labFilter.StateFilter) &gt; 0

        result := make([]LabOut, 0)
        for _, lab := range labs </span><span class="cov8" title="1">{
                s.instancesMutex.Lock()
                instance, hasInstance := s.instances[lab.UUID]
                s.instancesMutex.Unlock()

                if hasStateFilter </span><span class="cov8" title="1">{
                        instanceState := InstanceStates.Inactive

                        if hasInstance </span><span class="cov0" title="0">{
                                instanceState = instance.State
                        }</span> else<span class="cov8" title="1"> if s.labDeploymentSchedule.IsScheduled(lab.UUID) </span><span class="cov0" title="0">{
                                instanceState = InstanceStates.Scheduled
                        }</span>

                        <span class="cov8" title="1">if !slices.Contains(labFilter.StateFilter, instanceState) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">result = append(result, LabOut{
                        ID:                 lab.UUID,
                        Name:               lab.Name,
                        StartTime:          lab.StartTime,
                        EndTime:            lab.EndTime,
                        TopologyId:         lab.Topology.UUID,
                        CollectionId:       lab.Topology.Collection.UUID,
                        Creator:            s.userRepo.UserToOut(lab.Creator),
                        TopologyDefinition: *lab.TopologyDefinition,
                        Instance:           s.instanceToOut(instance),
                        InstanceName:       lab.InstanceName,
                })</span>
        }

        <span class="cov8" title="1">return result, err</span>
}

func (s *labService) GetByUuid(ctx *gin.Context, labId string, authUser auth.AuthenticatedUser) (*LabOut, error) <span class="cov0" title="0">{
        var (
                lab *Lab
                err error
        )
        if lab, err = s.labRepo.GetByUuid(ctx, labId); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Deny request if user doesn't have access to the lab
        <span class="cov0" title="0">if !authUser.IsAdmin &amp;&amp; !slices.Contains(authUser.Collections, lab.Topology.Collection.UUID) </span><span class="cov0" title="0">{
                return nil, utils.ErrorNoAccessToLab
        }</span>

        <span class="cov0" title="0">s.instancesMutex.Lock()
        instance, _ := s.instances[lab.UUID]
        s.instancesMutex.Unlock()

        result := &amp;LabOut{
                ID:                 lab.UUID,
                Name:               lab.Name,
                StartTime:          lab.StartTime,
                EndTime:            lab.EndTime,
                TopologyId:         lab.Topology.UUID,
                CollectionId:       lab.Topology.Collection.UUID,
                Creator:            s.userRepo.UserToOut(lab.Creator),
                TopologyDefinition: *lab.TopologyDefinition,
                Instance:           s.instanceToOut(instance),
                InstanceName:       lab.InstanceName,
        }

        return result, err</span>
}

func (s *labService) Create(ctx *gin.Context, req LabIn, authUser auth.AuthenticatedUser) (string, error) <span class="cov8" title="1">{
        labTopology, err := s.topologyRepo.GetByUuid(ctx, *req.TopologyId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Deny request if user does not have access to the lab topology's collection
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; (!labTopology.Collection.PublicDeploy || !slices.Contains(authUser.Collections, labTopology.Collection.Name)) </span><span class="cov8" title="1">{
                return "", utils.ErrorNoDeployAccessToCollection
        }</span>

        <span class="cov8" title="1">creator, err := s.userRepo.GetByUuid(ctx, authUser.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return "", utils.ErrorUnauthorized
        }</span>

        <span class="cov8" title="1">topologyDefinition, _, err := s.topologyService.LoadTopology(labTopology.UUID, []topology.BindFile{})
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to read definition of topology '%s': %s", labTopology.UUID, err.Error())
                return "", utils.ErrorAntimony
        }</span>

        <span class="cov8" title="1">labUuid := utils.GenerateUuid()
        lab := &amp;Lab{
                UUID:               labUuid,
                Name:               *req.Name,
                StartTime:          *req.StartTime,
                EndTime:            req.EndTime,
                Creator:            *creator,
                Topology:           *labTopology,
                TopologyDefinition: &amp;topologyDefinition,
        }

        if err := s.labRepo.Create(ctx, lab); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Add newly created lab to the deployment schedule
        <span class="cov8" title="1">s.labDeploymentSchedule.Schedule(lab)

        // Send update to clients
        s.notifyUpdate(*lab, nil)

        return labUuid, nil</span>
}

func (s *labService) Update(ctx *gin.Context, req LabInPartial, labId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested lab or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != lab.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToLab
        }</span>

        // Don't allow modifications to running labs
        <span class="cov8" title="1">s.instancesMutex.Lock()
        if _, hasInstance := s.instances[lab.UUID]; hasInstance </span><span class="cov0" title="0">{
                return utils.ErrorLabRunning
        }</span>
        <span class="cov8" title="1">s.instancesMutex.Unlock()

        updateDeploymentSchedule := false
        updateDestructionSchedule := false

        if req.Indefinite != nil &amp;&amp; *req.Indefinite == true </span><span class="cov0" title="0">{
                lab.EndTime = nil
                updateDestructionSchedule = true
        }</span> else<span class="cov8" title="1"> if req.EndTime != nil </span><span class="cov8" title="1">{
                lab.EndTime = req.EndTime
                updateDestructionSchedule = true
        }</span>

        <span class="cov8" title="1">if req.StartTime != nil </span><span class="cov8" title="1">{
                lab.StartTime = *req.StartTime
                updateDeploymentSchedule = true
        }</span>

        <span class="cov8" title="1">if req.Name != nil </span><span class="cov8" title="1">{
                lab.Name = *req.Name
        }</span>

        <span class="cov8" title="1">if err := s.labRepo.Update(ctx, lab); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if updateDeploymentSchedule </span><span class="cov8" title="1">{
                s.labDeploymentSchedule.Reschedule(lab)
        }</span>

        <span class="cov8" title="1">if updateDestructionSchedule </span><span class="cov8" title="1">{
                s.labDestructionSchedule.Reschedule(lab)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *labService) Delete(ctx *gin.Context, labId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested lab or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != lab.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToLab
        }</span>

        // Don't allow the deletion of running labs
        <span class="cov8" title="1">s.instancesMutex.Lock()
        if instance, hasInstance := s.instances[lab.UUID]; hasInstance &amp;&amp; instance.State != InstanceStates.Failed </span><span class="cov0" title="0">{
                return utils.ErrorLabRunning
        }</span>
        <span class="cov8" title="1">s.instancesMutex.Unlock()

        if err := s.storageManager.DeleteRunEnvironment(lab.UUID); err != nil </span><span class="cov0" title="0">{
                s.statusMessageNamespace.Send(*statusMessage.Warning(
                        "Lab Manager", fmt.Sprintf("Failed to remove run environment for %s: %s", lab.Name, err.Error()),
                        "Failed to remove run environment", "lab", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ))
        }</span>

        <span class="cov8" title="1">return s.labRepo.Delete(ctx, lab)</span>
}

// Read a topology, changes its name and returns the re-marshalled output.
func (s *labService) renameTopology(topologyId string, topologyName string, runTopologyDefinition *string) error <span class="cov8" title="1">{
        var (
                topologyRaw        string
                topologyDefinition = make(map[interface{}]interface{})
        )
        if err := s.storageManager.ReadTopology(topologyId, &amp;topologyRaw); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := yaml.Unmarshal([]byte(topologyRaw), &amp;topologyDefinition); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">topologyDefinition["name"] = topologyName
        if runTopologyRaw, err := yaml.Marshal(topologyDefinition); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                *runTopologyDefinition = string(runTopologyRaw)
                return nil
        }</span>
}

func (s *labService) createLabEnvironment(lab *Lab) (string, string, error) <span class="cov8" title="1">{
        var (
                runTopologyName       string
                runTopologyDefinition string
                runTopologyFile       string
        )

        runTopologyName = fmt.Sprintf("%s_%d", strings.ReplaceAll(lab.Topology.Name, " ", "_"), time.Now().UnixMilli())
        if err := s.renameTopology(lab.Topology.UUID, runTopologyName, &amp;runTopologyDefinition); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if err := s.storageManager.CreateRunEnvironment(lab.Topology.UUID, lab.UUID, runTopologyDefinition, &amp;runTopologyFile); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">lab.InstanceName = &amp;runTopologyName
        if err := s.labRepo.Update(context.Background(), lab); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">return runTopologyFile, runTopologyDefinition, nil</span>
}

func (s *labService) destroyLab(lab *Lab, instance *Instance) error <span class="cov8" title="1">{
        // We have to ensure that we cancel any pending deployment operations before destroying
        if instance.DeploymentWorker != nil &amp;&amp; instance.DeploymentWorker.Context.Err() == nil </span><span class="cov0" title="0">{
                log.Infof("Deployment still running, cancelling")
                instance.DeploymentWorker.Cancel()

                s.notifyUpdate(*lab,
                        statusMessage.Info(
                                "Lab Manager",
                                fmt.Sprintf("Cancelling deployment of lab '%s' (%s)", lab.Name, lab.Topology.Name),
                                "Cancelling deployment of lab", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                        ),
                )
        }</span>

        // We need to wait for previous operations to complete before destroying the lab
        <span class="cov8" title="1">instance.Mutex.Lock()
        defer instance.Mutex.Unlock()

        // Close all open shells for all nodes in the lab
        for _, node := range instance.Nodes </span><span class="cov8" title="1">{
                s.closeNodeShells(node.Name)
        }</span>

        <span class="cov8" title="1">ctx := context.Background()

        s.updateStateAndNotify(*lab, InstanceStates.Stopping, statusMessage.Info(
                "Lab Manager",
                fmt.Sprintf("Destroying lab %s (%s)", lab.Name, lab.Topology.Name),
                "Destroying lab", "lab", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
        ), &amp;instance.LogNamespace)

        output, err := s.deploymentProvider.Destroy(ctx, instance.TopologyFile, func(data string) </span><span class="cov0" title="0">{
                instance.LogNamespace.Send(data)
        }</span>)
        <span class="cov8" title="1">streamClabOutput(instance.LogNamespace, output)

        if err != nil </span><span class="cov8" title="1">{
                s.statusMessageNamespace.Send(*statusMessage.Error(
                        "Lab Manager", fmt.Sprintf("Failed to destroy lab %s: %s", lab.Name, err.Error()),
                        "Failed to destroy lab", "lab", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ))
                return utils.ErrorContainerlab
        }</span>

        <span class="cov8" title="1">instance.LogNamespace.ClearBacklog()
        instance.LogNamespace = nil

        // Remove instance from lab and send update to clients
        s.instancesMutex.Lock()
        delete(s.instances, lab.UUID)
        s.instancesMutex.Unlock()
        s.labUpdatesNamespace.Send(lab.UUID)

        s.statusMessageNamespace.Send(*statusMessage.Success(
                "Lab Manager", fmt.Sprintf("Successfully destroyed lab %s", lab.Name),
                "Lab has been destroyed successfully", "lab", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
        ))

        return nil</span>
}

func (s *labService) redeployLab(lab *Lab, instance *Instance) error <span class="cov8" title="1">{
        // We have to ensure that the instance isn't already being deployed
        if instance.State == InstanceStates.Deploying </span><span class="cov8" title="1">{
                s.notifyUpdate(*lab,
                        statusMessage.Error(
                                "Lab Manager",
                                fmt.Sprintf("Unable to redeploy lab '%s' (%s). The lab is already being deployed", lab.Name, lab.Topology.Name),
                                "Failed to deploy lab: The lab is already being deployed", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                        ),
                )
                return utils.ErrorLabIsDeploying
        }</span>

        <span class="cov8" title="1">instance.Mutex.Lock()
        defer instance.Mutex.Unlock()

        ctx, cancel := context.WithCancel(context.Background())
        instance.DeploymentWorker = &amp;utils.Worker{
                Context: ctx,
                Cancel:  cancel,
        }
        defer instance.DeploymentWorker.Cancel()

        // Close all open shells for all nodes in the lab
        for _, node := range instance.Nodes </span><span class="cov8" title="1">{
                s.closeNodeShells(node.Name)
        }</span>

        // Remove old nodes from instance
        <span class="cov8" title="1">instance.Nodes = make([]InstanceNode, 0)

        s.updateStateAndNotify(*lab, InstanceStates.Deploying, statusMessage.Info(
                "Lab Manager",
                fmt.Sprintf("Redeploying lab '%s' (%s)", lab.Name, lab.Topology.Name),
                "Starting redeployment of lab", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
        ), &amp;instance.LogNamespace)

        output, err := s.deploymentProvider.Redeploy(ctx, instance.TopologyFile, func(data string) </span><span class="cov8" title="1">{
                instance.LogNamespace.Send(data)
        }</span>)

        <span class="cov8" title="1">streamClabOutput(instance.LogNamespace, output)

        // Only report errors if the worker has not been cancelled
        if err != nil &amp;&amp; instance.DeploymentWorker.Context.Err() == nil </span><span class="cov8" title="1">{
                s.updateStateAndNotify(*lab, InstanceStates.Failed, statusMessage.Error(
                        "Lab Manager",
                        fmt.Sprintf("Failed to redeploy lab '%s' (%s)", lab.Name, lab.Topology.Name),
                        "Failed to redeploy lab", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ), &amp;instance.LogNamespace)
                s.setTopologyDeployStatus(*lab, false)
                return utils.ErrorContainerlab
        }</span>

        // Fetch and attach lab inspect info and change state to running if successful
        <span class="cov8" title="1">instanceNodes, err := s.getNodesFromInspect(ctx, instance.TopologyFile, *lab.InstanceName, func(data string) </span><span class="cov0" title="0">{
                instance.LogNamespace.Send(data)
        }</span>)

        // Only report errors if the deployment worker has not been cancelled
        <span class="cov8" title="1">if err != nil &amp;&amp; instance.DeploymentWorker.Context.Err() == nil </span><span class="cov0" title="0">{
                s.updateStateAndNotify(*lab, InstanceStates.Failed, statusMessage.Warning(
                        "Lab Manager",
                        fmt.Sprintf("Failed to get info of lab '%s' (%s)", lab.Name, lab.Topology.Name),
                        "Inspection of lab failed", "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ), &amp;instance.LogNamespace)
                s.setTopologyDeployStatus(*lab, false)
                return utils.ErrorContainerlab
        }</span>

        <span class="cov8" title="1">log.Infof("[SCHEDULER] Successfully redeployed lab '%s'!", lab.Name)
        s.instances[lab.UUID].Nodes = instanceNodes
        for _, node := range instanceNodes </span><span class="cov8" title="1">{
                containerLogNamespace := socket.CreateOutputNamespace[string](
                        s.socketManager, false, true, nil, "logs", lab.UUID, node.ContainerId,
                )
                err := s.deploymentProvider.StreamContainerLogs(ctx, "", node.ContainerId, func(data string) </span><span class="cov0" title="0">{
                        containerLogNamespace.Send(data)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to setup container logs for container %s: %s", node.ContainerId, err.Error())
                }</span>
        }

        <span class="cov8" title="1">s.updateStateAndNotify(*lab, InstanceStates.Running, statusMessage.Success(
                "Lab Manager",
                fmt.Sprintf("Successfully redeployed '%s' (%s)", lab.Name, lab.Topology.Name),
                "Redeployment of lab was successful", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
        ), &amp;instance.LogNamespace)
        s.setTopologyDeployStatus(*lab, true)

        instance.DeploymentWorker.Context.Done()

        return nil</span>
}

func (s *labService) deployLab(lab *Lab) error <span class="cov8" title="1">{
        // We have to ensure that the instance is only created once
        s.instancesMutex.Lock()

        if _, hasInstance := s.instances[lab.UUID]; hasInstance </span><span class="cov8" title="1">{
                s.notifyUpdate(*lab,
                        statusMessage.Error(
                                "Lab Manager",
                                fmt.Sprintf("Unable to deploy lab '%s' (%s). The lab is already being deployed", lab.Name, lab.Topology.Name),
                                "Failed to deploy lab: The lab is already being deployed", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                        ),
                )
                return utils.ErrorLabIsDeploying
        }</span>

        <span class="cov8" title="1">logNamespace := socket.CreateOutputNamespace[string](s.socketManager, false, true, nil, "logs", lab.UUID)

        runTopologyFile, _, err := s.createLabEnvironment(lab)

        instance := s.createInstance(logNamespace, runTopologyFile)
        s.instances[lab.UUID] = instance
        s.instancesMutex.Unlock()

        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Failed to create lab environment for lab '%s': %s", lab.Name, err)
                s.updateStateAndNotify(*lab, InstanceStates.Failed, statusMessage.Error(
                        "Lab Manager",
                        fmt.Sprintf("Failed to create environment for lab '%s' (%s)", lab.Name, lab.Topology.Name),
                        "Failed to create environment for lab", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ), &amp;logNamespace)
                s.setTopologyDeployStatus(*lab, false)
                return utils.ErrorAntimony
        }</span>

        <span class="cov8" title="1">instance.Mutex.Lock()
        defer instance.Mutex.Unlock()

        ctx, cancel := context.WithCancel(context.Background())
        instance.DeploymentWorker = &amp;utils.Worker{
                Context: ctx,
                Cancel:  cancel,
        }
        defer instance.DeploymentWorker.Cancel()

        s.updateStateAndNotify(*lab, InstanceStates.Deploying, statusMessage.Info(
                "Lab Manager",
                fmt.Sprintf("Deploying lab '%s' (%s)", lab.Name, lab.Topology.Name),
                "Starting deployment of lab", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
        ), &amp;instance.LogNamespace)

        output, err := s.deploymentProvider.Deploy(ctx, runTopologyFile, func(data string) </span><span class="cov0" title="0">{
                instance.LogNamespace.Send(data)
        }</span>)

        <span class="cov8" title="1">streamClabOutput(instance.LogNamespace, output)

        // Only report errors if the deployment worker has not been cancelled
        if err != nil &amp;&amp; instance.DeploymentWorker.Context.Err() == nil </span><span class="cov8" title="1">{
                s.updateStateAndNotify(*lab, InstanceStates.Failed, statusMessage.Error(
                        "Lab Manager",
                        fmt.Sprintf("Failed to deploy lab '%s' (%s)", lab.Name, lab.Topology.Name),
                        "Deployment of lab failed", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ), &amp;instance.LogNamespace)
                s.setTopologyDeployStatus(*lab, false)
                return utils.ErrorContainerlab
        }</span>

        // Fetch and attach lab inspect info and change state to running if successful
        <span class="cov8" title="1">instanceNodes, err := s.getNodesFromInspect(ctx, runTopologyFile, *lab.InstanceName, func(data string) </span><span class="cov0" title="0">{
                instance.LogNamespace.Send(data)
        }</span>)

        // Only report errors if the deployment worker has not been cancelled
        <span class="cov8" title="1">if err != nil &amp;&amp; instance.DeploymentWorker.Context.Err() == nil </span><span class="cov0" title="0">{
                s.updateStateAndNotify(*lab, InstanceStates.Failed, statusMessage.Warning(
                        "Lab Manager",
                        fmt.Sprintf("Failed to get info of lab '%s' (%s)", lab.Name, lab.Topology.Name),
                        "Inspection of lab failed", "instance", *lab.InstanceName, "topo", lab.Topology.Name,
                ), &amp;instance.LogNamespace)
                s.setTopologyDeployStatus(*lab, false)
                return utils.ErrorContainerlab
        }</span>

        <span class="cov8" title="1">log.Infof("[SCHEDULER] Successfully deployed lab '%s'!", lab.Name)
        s.instances[lab.UUID].Nodes = instanceNodes
        for _, node := range instanceNodes </span><span class="cov0" title="0">{
                containerLogNamespace := socket.CreateOutputNamespace[string](
                        s.socketManager, false, true, nil, "logs", lab.UUID, node.ContainerId,
                )
                err := s.deploymentProvider.StreamContainerLogs(ctx, "", node.ContainerId, func(data string) </span><span class="cov0" title="0">{
                        containerLogNamespace.Send(data)
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to setup container logs for container %s: %s", node.ContainerId, err.Error())
                }</span>
        }

        <span class="cov8" title="1">s.updateStateAndNotify(*lab, InstanceStates.Running, statusMessage.Success(
                "Lab Manager",
                fmt.Sprintf("Successfully deployed '%s' (%s)", lab.Name, lab.Topology.Name),
                "Deployment of lab was successful", "id", lab.UUID, "instance", *lab.InstanceName, "topo", lab.Topology.Name,
        ), &amp;instance.LogNamespace)
        s.setTopologyDeployStatus(*lab, true)

        instance.DeploymentWorker.Context.Done()

        return nil</span>
}

// setTopologyDeployStatus Sets the LastDeployFailed flag in the lab's topology
func (s *labService) setTopologyDeployStatus(lab Lab, wasSuccessful bool) <span class="cov8" title="1">{
        lab.Topology.LastDeployFailed = !wasSuccessful
        if err := s.topologyRepo.Update(context.Background(), &amp;lab.Topology); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to set last deployment failed on topology", "topo", lab.Topology.UUID)
        }</span>
}

func (s *labService) createInstance(
        logNamespace socket.OutputNamespace[string],
        runTopologyFile string,
) *Instance <span class="cov8" title="1">{
        return &amp;Instance{
                Deployed:          time.Now(),
                LatestStateChange: time.Now(),
                State:             InstanceStates.Deploying,
                Recovered:         false,
                Mutex:             sync.Mutex{},
                DeploymentWorker:  nil,
                LogNamespace:      logNamespace,
                TopologyFile:      runTopologyFile,
        }
}</span>

func (s *labService) instanceToOut(instance *Instance) *InstanceOut <span class="cov8" title="1">{
        if instance == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;InstanceOut{
                Deployed:          instance.Deployed,
                EdgesharkLink:     instance.EdgesharkLink,
                State:             instance.State,
                LatestStateChange: instance.LatestStateChange,
                Nodes:             instance.Nodes,
                Recovered:         instance.Recovered,
        }</span>
}

func (s *labService) updateInstanceNodes(
        ctx context.Context,
        instance *Instance,
        instanceName string,
        sendLogs bool,
) error <span class="cov8" title="1">{
        var onLog func(string)

        if sendLogs &amp;&amp; instance.LogNamespace != nil </span><span class="cov8" title="1">{
                onLog = func(data string) </span><span class="cov0" title="0">{
                        instance.LogNamespace.Send(data)
                }</span>
        }

        <span class="cov8" title="1">updatedNodes, err := s.getNodesFromInspect(ctx, instance.TopologyFile, instanceName, onLog)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">instance.Mutex.Lock()
        instance.Nodes = updatedNodes
        instance.Mutex.Unlock()

        return nil</span>
}

func (s *labService) getNodesFromInspect(
        ctx context.Context,
        runTopologyFile string,
        instanceName string,
        onLog func(data string),
) ([]InstanceNode, error) <span class="cov8" title="1">{
        inspectOutput, err := s.deploymentProvider.Inspect(ctx, runTopologyFile, onLog)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">containers := inspectOutput[instanceName]

        return lo.Map(containers, s.containerToInstanceNode), nil</span>
}

func (s *labService) containerToInstanceNode(container deployment.InspectContainer, _ int) InstanceNode <span class="cov8" title="1">{
        nodeNameParts := strings.Split(container.Name, "-")

        return InstanceNode{
                Name:          nodeNameParts[len(nodeNameParts)-1],
                IPv4:          container.IPv4Address,
                IPv6:          container.IPv6Address,
                Port:          50005,
                User:          "ins",
                WebSSH:        "",
                State:         container.State,
                ContainerId:   container.ContainerId,
                ContainerName: container.Name,
        }
}</span>

func (s *labService) notifyUpdate(lab Lab, message *statusMessage.StatusMessage) <span class="cov8" title="1">{
        s.labUpdatesNamespace.Send(lab.UUID)

        if message != nil </span><span class="cov8" title="1">{
                s.statusMessageNamespace.Send(*message)
        }</span>
}

// updateStateAndNotify Updates the state of a lab and sends various notification updates.
// If the status message is set, all users will receive the status message.
// If the log namespace is set, the log content of the status message is also sent to the provided namespace.
func (s *labService) updateStateAndNotify(lab Lab, state InstanceState, statusMessage *statusMessage.StatusMessage, logNamespace *socket.OutputNamespace[string]) <span class="cov8" title="1">{
        s.instances[lab.UUID].State = state
        s.instances[lab.UUID].LatestStateChange = time.Now()
        s.labUpdatesNamespace.Send(lab.UUID)

        if statusMessage != nil </span><span class="cov8" title="1">{
                s.statusMessageNamespace.Send(*statusMessage)
                if logNamespace != nil </span><span class="cov8" title="1">{
                        (*logNamespace).Send(statusMessage.LogContent)
                }</span>
        }
}

func (s *labService) reviveLabs() <span class="cov8" title="1">{
        ctx := context.Background()

        labs, err := s.labRepo.GetAll(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load labs from database. Exiting.")
                return
        }</span>

        <span class="cov8" title="1">result, err := s.deploymentProvider.InspectAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to retrieve containers from clab inspect. Exiting.", "err", err.Error())
                return
        }</span>

        <span class="cov8" title="1">for _, lab := range labs </span><span class="cov8" title="1">{
                if lab.InstanceName == nil </span><span class="cov8" title="1">{
                        if lab.StartTime.Unix() &gt;= time.Now().Unix() </span><span class="cov8" title="1">{
                                // The lab has not been run before
                                s.labDeploymentSchedule.Schedule(&amp;lab)
                        }</span>

                        <span class="cov8" title="1">continue</span>
                }

                // The lab has been deployed before
                <span class="cov8" title="1">if containers, ok := result[*lab.InstanceName]; ok </span><span class="cov8" title="1">{
                        // Lab is currently running
                        logNamespace := socket.CreateOutputNamespace[string](
                                s.socketManager, false, true, nil, "logs", lab.UUID,
                        )

                        // Create log namespaces for each container in the lab
                        for _, container := range containers </span><span class="cov8" title="1">{
                                containerLogNamespace := socket.CreateOutputNamespace[string](
                                        s.socketManager, false, true, nil, "logs", lab.UUID, container.ContainerId,
                                )
                                err := s.deploymentProvider.StreamContainerLogs(
                                        ctx, "", container.ContainerId, func(data string) </span><span class="cov0" title="0">{
                                                containerLogNamespace.Send(data)
                                        }</span>,
                                )
                                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                        log.Errorf(
                                                "Failed to setup container logs for container %s: %s", container.ContainerId, err.Error(),
                                        )
                                }</span>
                        }

                        <span class="cov8" title="1">s.instancesMutex.Lock()
                        s.instances[lab.UUID] = &amp;Instance{
                                State:             InstanceStates.Running,
                                Nodes:             lo.Map(containers, s.containerToInstanceNode),
                                Deployed:          time.Now(),
                                LatestStateChange: time.Now(),
                                Recovered:         true,
                                TopologyFile:      s.storageManager.GetRunTopologyFile(lab.UUID),
                                LogNamespace:      logNamespace,
                        }
                        s.instancesMutex.Unlock()

                        s.labDestructionSchedule.Schedule(&amp;lab)</span>
                }
        }
}

func (s *labService) handleLabCommand(
        ctx context.Context,
        data *LabCommandData,
        authUser *auth.AuthenticatedUser,
        onResponse func(response utils.OkResponse[any]),
        onError func(response utils.ErrorResponse),
) <span class="cov8" title="1">{
        if data.LabId == nil || data.Command == nil </span><span class="cov0" title="0">{
                onError(utils.CreateSocketErrorResponse(utils.ErrorInvalidSocketRequest))
                return
        }</span>

        <span class="cov8" title="1">switch *data.Command </span>{
        case LabCommands.Deploy:<span class="cov8" title="1">
                if err := s.deployLabCommand(ctx, *data.LabId, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                        return
                }</span>
                <span class="cov8" title="1">onResponse(utils.CreateSocketOkResponse[any](nil))
                break</span>
        case LabCommands.Destroy:<span class="cov8" title="1">
                if err := s.destroyLabCommand(ctx, *data.LabId, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                        return
                }</span>
                <span class="cov8" title="1">onResponse(utils.CreateSocketOkResponse[any](nil))
                break</span>
        case LabCommands.StartNode:<span class="cov8" title="1">
                if err := s.startNodeCommand(ctx, *data.LabId, data.Node, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                        return
                }</span>
                <span class="cov0" title="0">onResponse(utils.CreateSocketOkResponse[any](nil))
                break</span>
        case LabCommands.StopNode:<span class="cov8" title="1">
                if err := s.stopNodeCommand(ctx, *data.LabId, data.Node, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                        return
                }</span>
                <span class="cov0" title="0">onResponse(utils.CreateSocketOkResponse[any](nil))
                break</span>
        case LabCommands.RestartNode:<span class="cov8" title="1">
                if err := s.restartNodeCommand(ctx, *data.LabId, data.Node, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                        return
                }</span>
                <span class="cov8" title="1">onResponse(utils.CreateSocketOkResponse[any](nil))
                break</span>
        case LabCommands.FetchShells:<span class="cov8" title="1">
                if shells, err := s.fetchShellsCommand(ctx, *data.LabId, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                }</span> else<span class="cov8" title="1"> {
                        onResponse(utils.CreateSocketOkResponse[any](shells))
                }</span>
                <span class="cov8" title="1">break</span>
        case LabCommands.OpenShell:<span class="cov8" title="1">
                if shellId, err := s.openShellCommand(ctx, *data.LabId, data.Node, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                }</span> else<span class="cov8" title="1"> {
                        onResponse(utils.CreateSocketOkResponse[any](shellId))
                }</span>
                <span class="cov8" title="1">break</span>
        case LabCommands.CloseShell:<span class="cov8" title="1">
                if err := s.closeShellCommand(data.ShellId, authUser); err != nil </span><span class="cov8" title="1">{
                        onError(utils.CreateSocketErrorResponse(err))
                        return
                }</span>
                <span class="cov8" title="1">onResponse(utils.CreateSocketOkResponse[any](nil))</span>
        default:<span class="cov8" title="1">
                onError(utils.CreateSocketErrorResponse(utils.ErrorInvalidLabCommand))
                break</span>
        }
}

func (s *labService) destroyLabCommand(ctx context.Context, labId string, authUser *auth.AuthenticatedUser) error <span class="cov8" title="1">{
        lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested lab or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != lab.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoDestroyAccessToLab
        }</span>

        // Don't allow destroying non-running labs
        <span class="cov8" title="1">s.instancesMutex.Lock()
        instance, hasInstance := s.instances[lab.UUID]
        s.instancesMutex.Unlock()

        if !hasInstance </span><span class="cov8" title="1">{
                return utils.ErrorLabNotRunning
        }</span>

        <span class="cov8" title="1">s.labDestructionSchedule.Remove(lab.UUID)

        if err := s.destroyLab(lab, instance); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *labService) deployLabCommand(ctx context.Context, labId string, authUser *auth.AuthenticatedUser) error <span class="cov8" title="1">{
        lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested lab or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != lab.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoDeployAccessToLab
        }</span>

        <span class="cov8" title="1">s.instancesMutex.Lock()
        instance, hasInstance := s.instances[lab.UUID]
        s.instancesMutex.Unlock()

        if hasInstance </span><span class="cov8" title="1">{
                if err := s.redeployLab(lab, instance); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // Manually remove the lab from the lab schedule and add it to the destruction schedule
                s.labDeploymentSchedule.Remove(lab.UUID)

                // When redeploying a lab that has already ended, set its end time to indefinite
                if lab.EndTime != nil &amp;&amp; lab.EndTime.Unix() &lt;= time.Now().Unix() </span><span class="cov0" title="0">{
                        lab.EndTime = nil
                        if err := s.labRepo.Update(context.Background(), lab); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Failed to update lab end time: %s", err.Error())
                        }</span>
                }

                <span class="cov0" title="0">s.labDestructionSchedule.Schedule(lab)

                if err := s.deployLab(lab); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *labService) startNodeCommand(
        ctx context.Context,
        labId string,
        nodeId *string,
        authUser *auth.AuthenticatedUser,
) error <span class="cov8" title="1">{
        lab, instance, node, err := s.validateNodeCommand(ctx, labId, nodeId, authUser)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.deploymentProvider.StartNode(ctx, node.ContainerId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.updateInstanceNodes(ctx, instance, *lab.InstanceName, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.notifyUpdate(*lab, statusMessage.Success(
                "Lab Manager",
                fmt.Sprintf("Node %s is starting", node.Name),
                "Starting of node has been issued", "nodeId", node.ContainerId, "labId", lab.UUID,
        ))

        return nil</span>
}

func (s *labService) stopNodeCommand(
        ctx context.Context,
        labId string,
        nodeName *string,
        authUser *auth.AuthenticatedUser,
) error <span class="cov8" title="1">{
        lab, instance, node, err := s.validateNodeCommand(ctx, labId, nodeName, authUser)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">s.closeNodeShells(node.Name)

        if err := s.deploymentProvider.StopNode(ctx, node.ContainerId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.updateInstanceNodes(ctx, instance, *lab.InstanceName, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.notifyUpdate(*lab, statusMessage.Success(
                "Lab Manager",
                fmt.Sprintf("Node %s is stopping", node.Name),
                "Stopping of node has been issued", "nodeId", node.ContainerId, "labId", lab.UUID,
        ))

        return nil</span>
}

func (s *labService) restartNodeCommand(
        ctx context.Context,
        labId string,
        nodeId *string,
        authUser *auth.AuthenticatedUser,
) error <span class="cov8" title="1">{
        lab, instance, node, err := s.validateNodeCommand(ctx, labId, nodeId, authUser)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">s.closeNodeShells(node.Name)

        if err := s.deploymentProvider.RestartNode(ctx, node.ContainerId); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := s.updateInstanceNodes(ctx, instance, *lab.InstanceName, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.notifyUpdate(*lab, statusMessage.Success(
                "Lab Manager",
                fmt.Sprintf("Node %s is restarting", node.Name),
                "Restart of node has been issued", "nodeId", node.ContainerId, "labId", lab.UUID,
        ))

        return nil</span>
}

func (s *labService) validateNodeCommand(
        ctx context.Context,
        labId string,
        nodeName *string,
        authUser *auth.AuthenticatedUser,
) (*Lab, *Instance, *InstanceNode, error) <span class="cov8" title="1">{
        if nodeName == nil </span><span class="cov8" title="1">{
                return nil, nil, nil, utils.ErrorNodeNotFound
        }</span>

        <span class="cov8" title="1">lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        // Deny request if user is not the owner of the requested lab or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != lab.Creator.UUID </span><span class="cov0" title="0">{
                return nil, nil, nil, utils.ErrorNoDestroyAccessToLab
        }</span>

        // Don't allow destroying non-running labs
        <span class="cov8" title="1">s.instancesMutex.Lock()
        instance, hasInstance := s.instances[lab.UUID]
        s.instancesMutex.Unlock()

        if !hasInstance </span><span class="cov0" title="0">{
                return nil, nil, nil, utils.ErrorLabNotRunning
        }</span>

        <span class="cov8" title="1">node, hasNode := lo.Find(instance.Nodes, func(node InstanceNode) bool </span><span class="cov8" title="1">{
                return node.Name == *nodeName
        }</span>)

        <span class="cov8" title="1">if !hasNode </span><span class="cov0" title="0">{
                return nil, nil, nil, utils.ErrorNodeNotFound
        }</span>

        <span class="cov8" title="1">return lab, instance, &amp;node, nil</span>
}

func (s *labService) fetchShellsCommand(
        ctx context.Context,
        labId string,
        authUser *auth.AuthenticatedUser,
) ([]ShellData, error) <span class="cov8" title="1">{
        lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; !slices.Contains(authUser.Collections, lab.Topology.Collection.UUID) </span><span class="cov0" title="0">{
                return nil, utils.ErrorNoAccessToLab
        }</span>

        <span class="cov8" title="1">var userShells []ShellData

        s.openShellsMutex.Lock()
        for shellId, shell := range s.openShells </span><span class="cov0" title="0">{
                if shell.LabId == labId &amp;&amp; shell.Owner.UserId == authUser.UserId </span><span class="cov0" title="0">{
                        userShells = append(userShells, ShellData{
                                Id:   shellId,
                                Node: shell.Node,
                        })
                }</span>
        }
        <span class="cov8" title="1">s.openShellsMutex.Unlock()

        return userShells, nil</span>
}

func (s *labService) openShellCommand(
        ctx context.Context,
        labId string,
        nodeName *string,
        authUser *auth.AuthenticatedUser,
) (string, error) <span class="cov8" title="1">{
        if nodeName == nil </span><span class="cov8" title="1">{
                return "", utils.ErrorInvalidSocketRequest
        }</span>

        <span class="cov8" title="1">lab, err := s.labRepo.GetByUuid(ctx, labId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; !slices.Contains(authUser.Collections, lab.Topology.Collection.UUID) </span><span class="cov0" title="0">{
                return "", utils.ErrorNoAccessToLab
        }</span>

        <span class="cov8" title="1">s.instancesMutex.Lock()
        instance, hasInstance := s.instances[lab.UUID]
        if !hasInstance </span><span class="cov0" title="0">{
                return "", utils.ErrorLabNotRunning
        }</span>
        <span class="cov8" title="1">s.instancesMutex.Unlock()

        node, hasNode := lo.Find(instance.Nodes, func(node InstanceNode) bool </span><span class="cov8" title="1">{
                return node.Name == *nodeName
        }</span>)
        <span class="cov8" title="1">if !hasNode </span><span class="cov0" title="0">{
                return "", utils.ErrorNodeNotFound
        }</span>

        <span class="cov8" title="1">s.openShellsMutex.Lock()
        userShellCount := lo.CountBy(lo.Values(s.openShells), func(shell *ShellConfig) bool </span><span class="cov0" title="0">{
                return shell.Owner.UserId == authUser.UserId
        }</span>)
        <span class="cov8" title="1">s.openShellsMutex.Unlock()

        if userShellCount &gt;= s.config.Shell.UserLimit </span><span class="cov0" title="0">{
                return "", utils.ErrorShellLimitReached
        }</span>

        <span class="cov8" title="1">connection, err := s.deploymentProvider.OpenShell(ctx, node.ContainerId)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to open shell: %s", err.Error())
                return "", err
        }</span>

        <span class="cov8" title="1">shellId := utils.GenerateUuid()

        accessGroup := []*auth.AuthenticatedUser{authUser}

        dataNamespace := socket.CreateIONamespace[string, string](
                s.socketManager,
                false,
                true,
                s.handleShellData(shellId),
                &amp;accessGroup,
                "shells", shellId,
        )

        ctx, cancel := context.WithCancel(context.Background())

        go func() </span><span class="cov8" title="1">{
                buf := make([]byte, 1024)
                for </span><span class="cov8" title="1">{
                        n, err := connection.Read(buf)
                        if err != nil </span><span class="cov8" title="1">{
                                // Only send an error if the connection hasn't been closed explicitly
                                if ctx.Err() == nil </span><span class="cov8" title="1">{
                                        s.shellCommandsNamespace.Send(ShellCommandData{
                                                LabId:   labId,
                                                Node:    *nodeName,
                                                ShellId: shellId,
                                                Command: ShellCommands.Error,
                                                Message: err.Error(),
                                        })
                                }</span>

                                <span class="cov8" title="1">break</span>
                        }

                        <span class="cov0" title="0">dataNamespace.Send(string(buf[:n]))</span>
                }
        }()

        <span class="cov8" title="1">shellConfig := &amp;ShellConfig{
                Owner:            authUser,
                Node:             *nodeName,
                LabId:            labId,
                Connection:       connection,
                ConnectionCancel: cancel,
                LastInteraction:  time.Now().Unix(),
                DataNamespace:    dataNamespace,
        }

        s.openShellsMutex.Lock()
        s.openShells[shellId] = shellConfig
        s.openShellsMutex.Unlock()

        return shellId, nil</span>
}

func (s *labService) closeShellCommand(shellId *string, authUser *auth.AuthenticatedUser) error <span class="cov8" title="1">{
        if shellId == nil </span><span class="cov0" title="0">{
                return utils.ErrorInvalidSocketRequest
        }</span>

        <span class="cov8" title="1">s.openShellsMutex.Lock()
        shell, hasShell := s.openShells[*shellId]
        s.openShellsMutex.Unlock()

        if !hasShell </span><span class="cov8" title="1">{
                return utils.ErrorShellNotFound
        }</span>

        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; shell.Owner != authUser </span><span class="cov0" title="0">{
                return utils.ErrorNoAccessToShell
        }</span>

        <span class="cov8" title="1">err := s.closeShell(*shellId, shell, "shell was closed by the user")
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to close shell: %s", err.Error())
        }</span>

        <span class="cov8" title="1">s.openShellsMutex.Lock()
        delete(s.openShells, *shellId)
        s.openShellsMutex.Unlock()

        return nil</span>
}

func (s *labService) closeNodeShells(nodeName string) <span class="cov8" title="1">{
        var removeShellIds []string

        s.openShellsMutex.Lock()
        for shellId, shell := range s.openShells </span><span class="cov0" title="0">{
                if shell.Node == nodeName </span><span class="cov0" title="0">{
                        err := s.closeShell(shellId, shell, "the shell's node has been stopped")
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Failed to close shell: %s", err.Error())
                        }</span>

                        <span class="cov0" title="0">removeShellIds = append(removeShellIds, shellId)</span>
                }
        }
        <span class="cov8" title="1">for _, id := range removeShellIds </span><span class="cov0" title="0">{
                delete(s.openShells, id)
        }</span>
        <span class="cov8" title="1">s.openShellsMutex.Unlock()</span>
}

func (s *labService) closeShell(shellId string, shell *ShellConfig, reason string) error <span class="cov8" title="1">{
        s.shellCommandsNamespace.Send(ShellCommandData{
                LabId:   shell.LabId,
                Node:    shell.Node,
                ShellId: shellId,
                Command: ShellCommands.Close,
                Message: reason,
        })

        shell.ConnectionCancel()

        return shell.Connection.Close()
}</span>

func (s *labService) handleShellData(
        shellId string,
) func(
        ctx context.Context,
        data *string,
        authUser *auth.AuthenticatedUser,
        onResponse func(response utils.OkResponse[any]),
        onError func(response utils.ErrorResponse),
) <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                data *string,
                authUser *auth.AuthenticatedUser,
                onResponse func(response utils.OkResponse[any]),
                onError func(response utils.ErrorResponse),
        ) </span><span class="cov0" title="0">{
                if data == nil </span><span class="cov0" title="0">{
                        onError(utils.CreateSocketErrorResponse(utils.ErrorInvalidSocketRequest))
                        return
                }</span>

                <span class="cov0" title="0">s.openShellsMutex.Lock()
                shell, hasShell := s.openShells[shellId]
                s.openShellsMutex.Unlock()

                if !hasShell </span><span class="cov0" title="0">{
                        if onError != nil </span><span class="cov0" title="0">{
                                onError(utils.CreateSocketErrorResponse(utils.ErrorShellNotFound))
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">if shell.Owner.UserId != authUser.UserId </span><span class="cov0" title="0">{
                        onError(utils.CreateSocketErrorResponse(utils.ErrorNoAccessToShell))
                        return
                }</span>

                <span class="cov0" title="0">shell.LastInteraction = time.Now().Unix()

                _, err := shell.Connection.Write(([]byte)(*data))
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to write shell data: %s", err.Error())
                        if onError != nil </span><span class="cov0" title="0">{
                                onError(utils.CreateSocketErrorResponse(err))
                        }</span>
                }
        }
}

// streamClabOutput Streams the output of a containerlab command to a given socket namespace.
func streamClabOutput(logNamespace socket.OutputNamespace[string], output *string) <span class="cov8" title="1">{
        re := regexp.MustCompile(`\[\dm`)
        if output == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for _, line := range strings.Split(*output, "\n") </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">logNamespace.Send(string(re.ReplaceAll([]byte(line), []byte(""))))</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package schema

import (
        "antimonyBackend/utils"
        "encoding/json"
        "github.com/gin-gonic/gin"
)

type (
        Handler interface {
                Get(ctx *gin.Context)
        }

        schemaHandler struct {
                schemaService Service
        }
)

func CreateHandler(schemaService Service) Handler <span class="cov8" title="1">{
        return &amp;schemaHandler{
                schemaService: schemaService,
        }
}</span>

// @Summary        Returns the JSON schema to validate topology definitions
// @Produce        json
// @Tags                schema
// @Success        200        {object}        utils.OkResponse[any]        "The schema as JSON object"
// @Router                /schema [get]
func (h *schemaHandler) Get(ctx *gin.Context) <span class="cov8" title="1">{
        var schemaObj any
        if err := json.Unmarshal([]byte(h.schemaService.Get()), &amp;schemaObj); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(schemaObj))</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package schema

import (
        "github.com/gin-gonic/gin"
)

func RegisterRoutes(route *gin.Engine, handler Handler) <span class="cov8" title="1">{
        routes := route.Group("/clab-schema")
        </span><span class="cov8" title="1">{
                routes.GET("", handler.Get)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package schema

import (
        "antimonyBackend/config"
        "encoding/json"
        "github.com/charmbracelet/log"
        "io"
        "net/http"
        "os"
        "strings"
)

type (
        Service interface {
                Get() string
        }

        schemaService struct {
                clabSchema string
        }
)

func CreateService(config *config.AntimonyConfig) Service <span class="cov8" title="1">{
        schema := loadSchema(config)

        return &amp;schemaService{
                clabSchema: schema,
        }
}</span>

func (u *schemaService) Get() string <span class="cov8" title="1">{
        return u.clabSchema
}</span>

func loadSchema(config *config.AntimonyConfig) string <span class="cov8" title="1">{
        var schema any

        if resp, err := http.Get(config.Containerlab.SchemaUrl); err != nil </span><span class="cov0" title="0">{
                log.Warn("Failed to download clab schema from remote resource. Falling back to local schema.")

                // Try to use local fallback schema instead
                if schemaData, err := os.ReadFile(config.Containerlab.SchemaFallback); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to read fallback clab schema. Exiting.")
                }</span> else<span class="cov0" title="0"> {
                        if err := json.Unmarshal(schemaData, &amp;schema); err != nil </span><span class="cov0" title="0">{
                                log.Fatal("Failed to parse fallback clab schema. Exiting.")
                        }</span>

                        <span class="cov0" title="0">return string(schemaData)</span>
                }
        } else<span class="cov8" title="1"> {
                buf := new(strings.Builder)
                if _, err := io.Copy(buf, resp.Body); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to parse remote clab schema. Exiting.")
                }</span>

                <span class="cov8" title="1">return buf.String()</span>
                //if err := json.NewDecoder(resp.Body).Decode(&amp;schema); err != nil {
                //        log.Fatal("Failed to parse remote clab schema. Exiting.")
                //} else {
                //        buf := new(strings.Builder)
                //        if _, err := io.Copy(buf, resp.Body); err != nil {
                //                log.Fatal("Failed to parse remote clab schema. Exiting.")
                //        }
                //
                //        return buf.String()
                //}
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package statusMessage

import (
        "antimonyBackend/types"
        "antimonyBackend/utils"
        "fmt"
        "time"
)

type StatusMessage struct {
        ID         string         `json:"id"`
        Source     string         `json:"source"`
        Content    string         `json:"content"`
        LogContent string         `json:"logContent"`
        Timestamp  time.Time      `json:"timestamp"`
        Severity   types.Severity `json:"severity"`
}

func Success(source string, content string, logContent ...string) *StatusMessage <span class="cov8" title="1">{
        return newStatusMessage(source, content, types.Success, logContent...)
}</span>

func Info(source string, content string, logContent ...string) *StatusMessage <span class="cov8" title="1">{
        return newStatusMessage(source, content, types.Info, logContent...)
}</span>

func Warning(source string, content string, logContent ...string) *StatusMessage <span class="cov0" title="0">{
        return newStatusMessage(source, content, types.Warning, logContent...)
}</span>

func Error(source string, content string, logContent ...string) *StatusMessage <span class="cov8" title="1">{
        return newStatusMessage(source, content, types.Error, logContent...)
}</span>

func Fatal(source string, content string, logContent ...string) *StatusMessage <span class="cov0" title="0">{
        return newStatusMessage(source, content, types.Fatal, logContent...)
}</span>

func newStatusMessage(source string, content string, severity types.Severity, logParts ...string) *StatusMessage <span class="cov8" title="1">{
        logContent := content
        if len(logParts) &gt; 0 </span><span class="cov8" title="1">{
                logMessage := logParts[0] + " "
                for i := 1; i &lt; len(logParts); i += 2 </span><span class="cov8" title="1">{
                        if i+1 &lt; len(logParts) </span><span class="cov8" title="1">{
                                logMessage = logMessage + fmt.Sprintf("%s=%s ", logParts[i], logParts[i+1])
                        }</span> else<span class="cov0" title="0"> {
                                logMessage = logMessage + logParts[i]
                        }</span>
                }
                <span class="cov8" title="1">logContent = fmt.Sprintf("%s ANTIMONY %s", time.Now().Format(time.TimeOnly), logMessage)</span>
        }

        <span class="cov8" title="1">return &amp;StatusMessage{
                ID:         utils.GenerateUuid(),
                Source:     source,
                Content:    content,
                Severity:   severity,
                LogContent: logContent,
                Timestamp:  time.Now(),
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package topology

import (
        "antimonyBackend/auth"
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
)

type (
        Handler interface {
                Get(ctx *gin.Context)
                Create(ctx *gin.Context)
                Update(ctx *gin.Context)
                Delete(ctx *gin.Context)

                CreateBindFile(ctx *gin.Context)
                UpdateBindFile(ctx *gin.Context)
                DeleteBindFile(ctx *gin.Context)
        }

        topologyHandler struct {
                topologyService Service
        }
)

func CreateHandler(topologyService Service) Handler <span class="cov8" title="1">{
        return &amp;topologyHandler{
                topologyService: topologyService,
        }
}</span>

// @Summary        Get all topologies
// @Produce        json
// @Tags                topologies
// @Security        BasicAuth
// @Success        200        {object}        utils.OkResponse[[]topology.TopologyOut]
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Router                /topologies [get]
func (h *topologyHandler) Get(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        result, err := h.topologyService.Get(ctx, authUser)
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Create a new topology
// @Accept                json
// @Produce        json
// @Tags                topologies
// @Security        BasicAuth
// @Success        200                {object}        utils.OkResponse[string]        "The ID of the newly created collection"
// @Failure        401                {object}        nil                                                        "The user isn't authorized"
// @Failure        498                {object}        nil                                                        "The provided access token is not valid"
// @Failure        403                {object}        utils.ErrorResponse                        "Access to the resource was denied. Details in the request body."
// @Param                request        body                topology.TopologyIn                        true        "The topology"
// @Router                /topologies [post]
func (h *topologyHandler) Create(ctx *gin.Context) <span class="cov8" title="1">{
        payload := TopologyIn{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        result, err := h.topologyService.Create(ctx, payload, authUser)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Update an existing topology
// @Accept                json
// @Produce        json
// @Tags                topologies
// @Security        BasicAuth
// @Success        200                {object}        nil
// @Failure        401                {object}        nil                                        "The user isn't authorized"
// @Failure        498                {object}        nil                                        "The provided access token is not valid"
// @Failure        403                {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422                {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                request        body                topology.TopologyIn        true        "The topology with updated values"
// @Param                id                path                string                                true        "The ID of the topology to edit"
// @Router                /topologies/{id} [patch]
func (h *topologyHandler) Update(ctx *gin.Context) <span class="cov8" title="1">{
        payload := TopologyInPartial{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.topologyService.Update(ctx, payload, ctx.Param("topologyId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}

// @Summary        Delete an existing topology
// @Produce        json
// @Tags                topologies
// @Security        BasicAuth
// @Success        200        {object}        nil
// @Failure        401        {object}        nil                                        "The user isn't authorized"
// @Failure        498        {object}        nil                                        "The provided access token is not valid"
// @Failure        403        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422        {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                id        path                string                                true        "The ID of the topology to delete"
// @Router                /topologies/{id} [delete]
func (h *topologyHandler) Delete(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.topologyService.Delete(ctx, ctx.Param("topologyId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}

// @Summary        Create a new bind file for a topology
// @Accept                json
// @Produce        json
// @Tags                bindFiles
// @Security        BasicAuth
// @Success        200                        {object}        utils.OkResponse[string]        "The ID of the newly created file"
// @Failure        401                        {object}        nil                                                        "The user isn't authorized"
// @Failure        498                        {object}        nil                                                        "The provided access token is not valid"
// @Failure        403                        {object}        utils.ErrorResponse                        "Access to the resource was denied. Details in the request body."
// @Param                request                body                topology.BindFileIn                        true        "The bind file"
// @Param                topologyId        path                string                                                true        "The ID of the topology the bind file should belong to"
// @Router                /topologies/{topologyId}/files [post]
func (h *topologyHandler) CreateBindFile(ctx *gin.Context) <span class="cov8" title="1">{
        payload := BindFileIn{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        result, err := h.topologyService.CreateBindFile(ctx, ctx.Param("topologyId"), payload, authUser)
        if err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse(result))</span>
}

// @Summary        Update an existing bind file of a topology
// @Produce        json
// @Tags                bindFiles
// @Security        BasicAuth
// @Success        200                        {object}        nil
// @Failure        401                        {object}        nil                                        "The user isn't authorized"
// @Failure        498                        {object}        nil                                        "The provided access token is not valid"
// @Failure        403                        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422                        {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                topologyId        path                string                                true        "The ID of the topology the bind file belongs to"
// @Param                bindFileId        path                string                                true        "The ID of the bind file to edit"
// @Router                /topologies/{topologyId}/files/{bindFileId} [patch]
func (h *topologyHandler) UpdateBindFile(ctx *gin.Context) <span class="cov8" title="1">{
        payload := BindFileInPartial{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateValidationError(err))
                return
        }</span>

        <span class="cov8" title="1">authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.topologyService.UpdateBindFile(ctx, payload, ctx.Param("fileId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}

// @Summary        Delete an existing bind file of a topology
// @Produce        json
// @Tags                bindFiles
// @Security        BasicAuth
// @Success        200                        {object}        nil
// @Failure        401                        {object}        nil                                        "The user isn't authorized"
// @Failure        498                        {object}        nil                                        "The provided access token is not valid"
// @Failure        403                        {object}        utils.ErrorResponse        "Access to the resource was denied. Details in the request body."
// @Failure        422                        {object}        utils.ErrorResponse        "The request was invalid. Details in the response body."
// @Param                topologyId        path                string                                true        "The ID of the topology the bind file belongs to"
// @Param                bindFileId        path                string                                true        "The ID of the bind file to delete"
// @Router                /topologies/{topologyId}/files/{bindFileId} [delete]
func (h *topologyHandler) DeleteBindFile(ctx *gin.Context) <span class="cov8" title="1">{
        authUser := ctx.MustGet("authUser").(auth.AuthenticatedUser)
        if err := h.topologyService.DeleteBindFile(ctx, ctx.Param("fileId"), authUser); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov8" title="1">ctx.JSON(utils.CreateOkResponse[any](nil))</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package topology

import (
        "antimonyBackend/utils"
        "context"
        "github.com/charmbracelet/log"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type (
        Repository interface {
                GetAll(ctx context.Context) ([]Topology, error)
                GetByUuid(ctx context.Context, topologyId string) (*Topology, error)
                GetByName(ctx context.Context, topologyName string, collectionId string) ([]Topology, error)
                GetFromCollections(ctx context.Context, collectionNames []string) ([]Topology, error)

                Create(ctx context.Context, topology *Topology) error
                Update(ctx context.Context, topology *Topology) error
                Delete(ctx context.Context, topology *Topology) error

                GetBindFileByUuid(ctx context.Context, bindFileId string) (*BindFile, error)
                GetBindFileForTopology(ctx context.Context, topologyId string) ([]BindFile, error)
                CreateBindFile(ctx context.Context, bindFile *BindFile) error
                UpdateBindFile(ctx context.Context, bindFile *BindFile) error
                DeleteBindFile(ctx context.Context, bindFile *BindFile) error
                DoesBindFilePathExist(ctx context.Context, bindFilePath string, topologyId string, excludeString string) (bool, error)
                BindFileToOut(bindFile BindFile, content string) BindFileOut
        }

        topologyRepository struct {
                db *gorm.DB
        }
)

func CreateRepository(db *gorm.DB) Repository <span class="cov8" title="1">{
        return &amp;topologyRepository{
                db: db,
        }
}</span>

func (r *topologyRepository) GetAll(ctx context.Context) ([]Topology, error) <span class="cov8" title="1">{
        var topologies []Topology
        result := r.db.WithContext(ctx).
                Preload(clause.Associations).
                Find(&amp;topologies)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch all topologies. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return topologies, nil</span>
}

func (r *topologyRepository) GetByUuid(ctx context.Context, topologyId string) (*Topology, error) <span class="cov8" title="1">{
        var topology Topology
        result := r.db.WithContext(ctx).Where("uuid = ?", topologyId).
                Preload("Collection").
                Preload("Creator").
                Find(&amp;topology)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return nil, utils.ErrorUuidNotFound
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch topology by UUID. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return &amp;topology, nil</span>
}

func (r *topologyRepository) GetByName(ctx context.Context, topologyName string, collectionId string) ([]Topology, error) <span class="cov8" title="1">{
        var topologies []Topology
        result := r.db.WithContext(ctx).
                Joins("JOIN collections ON collections.id = topologies.collection_id").
                Where("topologies.name = ? AND collections.uuid = ? AND topologies.deleted_at IS NULL", topologyName, collectionId).
                Limit(1).
                Find(&amp;topologies)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return topologies, nil
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch topologies by name. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return topologies, nil</span>
}

func (r *topologyRepository) GetFromCollections(ctx context.Context, collectionNames []string) ([]Topology, error) <span class="cov8" title="1">{
        var topologies []Topology
        result := r.db.WithContext(ctx).
                Preload(clause.Associations).
                Joins("JOIN collections ON collections.id = topologies.collection_id").
                Where("collections.name IN ?", collectionNames).
                Find(&amp;topologies)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return topologies, nil
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch topologies from collections. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return topologies, nil</span>
}

func (r *topologyRepository) Create(ctx context.Context, topology *Topology) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Create(topology).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to create topology. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *topologyRepository) Update(ctx context.Context, topology *Topology) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Save(topology).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to update topology. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *topologyRepository) Delete(ctx context.Context, topology *Topology) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Delete(topology).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to delete topology. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *topologyRepository) GetBindFileByUuid(ctx context.Context, bindFileId string) (*BindFile, error) <span class="cov8" title="1">{
        var bindFile BindFile
        result := r.db.WithContext(ctx).
                Preload("Topology").
                Where("uuid = ?", bindFileId).
                Find(&amp;bindFile)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return nil, utils.ErrorUuidNotFound
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to find bind file by UUID. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return &amp;bindFile, nil</span>
}

func (r *topologyRepository) GetBindFileForTopology(ctx context.Context, topologyId string) ([]BindFile, error) <span class="cov8" title="1">{
        var bindFiles []BindFile
        result := r.db.WithContext(ctx).
                Preload("Topology").
                Joins("JOIN topologies ON topologies.id = bind_files.topology_id").
                Where("topologies.uuid = ?", topologyId).
                Find(&amp;bindFiles)
        
        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to find bind files by topology. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return bindFiles, nil</span>
}

func (r *topologyRepository) CreateBindFile(ctx context.Context, bindFile *BindFile) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Create(bindFile).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to create bind file. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *topologyRepository) UpdateBindFile(ctx context.Context, bindFile *BindFile) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Save(bindFile).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to update bind file. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *topologyRepository) DeleteBindFile(ctx context.Context, bindFile *BindFile) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Delete(bindFile).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to update delete file. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *topologyRepository) BindFileToOut(bindFile BindFile, content string) BindFileOut <span class="cov8" title="1">{
        return BindFileOut{
                ID:         bindFile.UUID,
                FilePath:   bindFile.FilePath,
                Content:    content,
                TopologyId: bindFile.Topology.UUID,
        }
}</span>

func (r *topologyRepository) DoesBindFilePathExist(ctx context.Context, bindFilePath, topologyId, excludeUUID string) (bool, error) <span class="cov8" title="1">{
        var bindFile BindFile
        result := r.db.WithContext(ctx).
                Joins("JOIN topologies ON topologies.id = bind_files.topology_id").
                Where("bind_files.file_path = ? AND topologies.uuid = ? AND bind_files.uuid != ?", bindFilePath, topologyId, excludeUUID).
                Limit(1).
                Find(&amp;bindFile)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to check if bind file exist. Error: %s", result.Error.Error())
                return false, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return result.RowsAffected &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package topology

import (
        "antimonyBackend/auth"
        "github.com/gin-gonic/gin"
)

func RegisterRoutes(route *gin.Engine, handler Handler, authManager auth.AuthManager) <span class="cov8" title="1">{
        routes := route.Group("/topologies", authManager.AuthenticatorMiddleware())
        </span><span class="cov8" title="1">{
                routes.GET("", handler.Get)
                routes.POST("", handler.Create)
                routes.PATCH("/:topologyId", handler.Update)
                routes.DELETE("/:topologyId", handler.Delete)

                routes.POST("/:topologyId/files", handler.CreateBindFile)
                routes.PATCH("/:topologyId/files/:fileId", handler.UpdateBindFile)
                routes.DELETE("/:topologyId/files/:fileId", handler.DeleteBindFile)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package topology

import (
        "antimonyBackend/auth"
        "antimonyBackend/domain/collection"
        "antimonyBackend/domain/user"
        "antimonyBackend/storage"
        "antimonyBackend/utils"
        "github.com/charmbracelet/log"
        "github.com/gin-gonic/gin"
        "github.com/santhosh-tekuri/jsonschema/v5"
        "gopkg.in/yaml.v3"
        "slices"
        "strings"
)

type (
        Service interface {
                Get(ctx *gin.Context, authUser auth.AuthenticatedUser) ([]TopologyOut, error)
                Create(ctx *gin.Context, req TopologyIn, authUser auth.AuthenticatedUser) (string, error)
                Update(ctx *gin.Context, req TopologyInPartial, topologyId string, authUser auth.AuthenticatedUser) error
                Delete(ctx *gin.Context, topologyId string, authUser auth.AuthenticatedUser) error

                CreateBindFile(ctx *gin.Context, topologyId string, req BindFileIn, authUser auth.AuthenticatedUser) (string, error)
                UpdateBindFile(ctx *gin.Context, req BindFileInPartial, bindFileId string, authUser auth.AuthenticatedUser) error
                DeleteBindFile(ctx *gin.Context, bindFileId string, authUser auth.AuthenticatedUser) error

                LoadTopology(topologyId string, bindFiles []BindFile) (string, []BindFileOut, error)
        }

        topologyService struct {
                topologyRepo   Repository
                userRepo       user.Repository
                collectionRepo collection.Repository
                storageManager storage.StorageManager
                schemaLoader   *jsonschema.Schema
        }
)

func CreateService(
        topologyRepo Repository,
        userRepo user.Repository,
        collectionRepo collection.Repository,
        storageManager storage.StorageManager,
        clabSchema string,
) Service <span class="cov8" title="1">{
        compiler := jsonschema.NewCompiler()
        if err := compiler.AddResource("clab-schema.json", strings.NewReader(clabSchema)); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">schema, err := compiler.Compile("clab-schema.json")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return &amp;topologyService{
                topologyRepo:   topologyRepo,
                userRepo:       userRepo,
                collectionRepo: collectionRepo,
                storageManager: storageManager,
                schemaLoader:   schema,
        }</span>
}

func (s *topologyService) Get(ctx *gin.Context, authUser auth.AuthenticatedUser) ([]TopologyOut, error) <span class="cov8" title="1">{
        var (
                topologies []Topology
                err        error
        )

        if authUser.IsAdmin </span><span class="cov8" title="1">{
                topologies, err = s.topologyRepo.GetAll(ctx)
        }</span> else<span class="cov8" title="1"> {
                topologies, err = s.topologyRepo.GetFromCollections(ctx, authUser.Collections)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">result := make([]TopologyOut, 0)
        for _, topology := range topologies </span><span class="cov8" title="1">{
                var (
                        definition   string
                        bindFilesOut []BindFileOut
                        err          error
                )

                bindFiles, err := s.topologyRepo.GetBindFileForTopology(ctx, topology.UUID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to get bind files for topology '%s': %s", topology.UUID, err.Error())
                        continue</span>
                }

                <span class="cov8" title="1">if definition, bindFilesOut, err = s.LoadTopology(topology.UUID, bindFiles); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to read definition of topology '%s': %s", topology.UUID, err.Error())
                        continue</span>
                }

                <span class="cov8" title="1">result = append(result, TopologyOut{
                        ID:               topology.UUID,
                        Definition:       definition,
                        SyncUrl:          topology.SyncUrl,
                        CollectionId:     topology.Collection.UUID,
                        Creator:          s.userRepo.UserToOut(topology.Creator),
                        BindFiles:        bindFilesOut,
                        LastDeployFailed: topology.LastDeployFailed,
                })</span>
        }

        <span class="cov8" title="1">return result, err</span>
}

func (s *topologyService) Create(ctx *gin.Context, req TopologyIn, authUser auth.AuthenticatedUser) (string, error) <span class="cov8" title="1">{
        topologyCollection, err := s.collectionRepo.GetByUuid(ctx, *req.CollectionId)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Deny request if user does not have access to the target collection
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; (!topologyCollection.PublicWrite || !slices.Contains(authUser.Collections, topologyCollection.Name)) </span><span class="cov8" title="1">{
                return "", utils.ErrorNoWriteAccessToCollection
        }</span>

        <span class="cov8" title="1">if err := s.validateTopology(*req.Definition); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Don't allow duplicate topology names within the same collection
        <span class="cov8" title="1">topologyName := s.getNameFromDefinition(*req.Definition)
        if topologies, err := s.topologyRepo.GetByName(ctx, topologyName, *req.CollectionId); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> if len(topologies) &gt; 0 </span><span class="cov8" title="1">{
                return "", utils.ErrorTopologyExists
        }</span>

        <span class="cov8" title="1">newUuid := utils.GenerateUuid()
        if err := s.saveTopology(newUuid, *req.Definition); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">creatorUser, err := s.userRepo.GetByUuid(ctx, authUser.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return "", utils.ErrorUnauthorized
        }</span>

        <span class="cov8" title="1">err = s.topologyRepo.Create(ctx, &amp;Topology{
                UUID:             newUuid,
                Name:             topologyName,
                SyncUrl:          *req.SyncUrl,
                Collection:       *topologyCollection,
                Creator:          *creatorUser,
                LastDeployFailed: false,
        })

        return newUuid, err</span>
}

func (s *topologyService) Update(ctx *gin.Context, req TopologyInPartial, topologyId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        topology, err := s.topologyRepo.GetByUuid(ctx, topologyId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested topology or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != topology.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToTopology
        }</span>

        // Deny request if user does not have access to topology's collection
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; (!topology.Collection.PublicWrite &amp;&amp; !slices.Contains(authUser.Collections, topology.Collection.UUID)) </span><span class="cov0" title="0">{
                return utils.ErrorNoWriteAccessToCollection
        }</span>

        <span class="cov8" title="1">topologyCollection := topology.Collection
        topologyName := topology.Name

        if req.CollectionId != nil </span><span class="cov8" title="1">{
                newCollection, err := s.collectionRepo.GetByUuid(ctx, *req.CollectionId)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Deny change of collection if user does not have access to the new collection
                <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; (!newCollection.PublicWrite &amp;&amp; !slices.Contains(authUser.Collections, *req.CollectionId)) </span><span class="cov0" title="0">{
                        return utils.ErrorNoWriteAccessToCollection
                }</span>

                <span class="cov8" title="1">topologyCollection = *newCollection</span>
        }

        <span class="cov8" title="1">if req.Definition != nil </span><span class="cov8" title="1">{
                if err := s.validateTopology(*req.Definition); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">topologyName = s.getNameFromDefinition(*req.Definition)</span>
        }

        // Don't allow duplicate topology names within the same collection
        <span class="cov8" title="1">if topologyName != topology.Name </span><span class="cov8" title="1">{
                if topologies, err := s.topologyRepo.GetByName(ctx, topologyName, topologyCollection.UUID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if len(topologies) &gt; 0 </span><span class="cov8" title="1">{
                        return utils.ErrorTopologyExists
                }</span>
        }

        <span class="cov8" title="1">if req.Definition != nil </span><span class="cov8" title="1">{
                if err := s.saveTopology(topology.UUID, *req.Definition); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">topology.Name = topologyName
        topology.Collection = topologyCollection

        if req.SyncUrl != nil </span><span class="cov8" title="1">{
                topology.SyncUrl = *req.SyncUrl
        }</span>

        <span class="cov8" title="1">return s.topologyRepo.Update(ctx, topology)</span>
}

func (s *topologyService) Delete(ctx *gin.Context, topologyId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        topology, err := s.topologyRepo.GetByUuid(ctx, topologyId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user is not the owner of the requested topology or an admin
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != topology.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToTopology
        }</span>

        <span class="cov8" title="1">return s.topologyRepo.Delete(ctx, topology)</span>
}

func (s *topologyService) CreateBindFile(ctx *gin.Context, topologyId string, req BindFileIn, authUser auth.AuthenticatedUser) (string, error) <span class="cov8" title="1">{
        bindFileTopology, err := s.topologyRepo.GetByUuid(ctx, topologyId)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Deny request if user does not have access to the owning topology
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; bindFileTopology.Creator.UUID != authUser.UserId </span><span class="cov8" title="1">{
                return "", utils.ErrorNoWriteAccessToBindFile
        }</span>

        // Don't allow duplicate bind file names within the same topology
        <span class="cov8" title="1">if nameExists, err := s.topologyRepo.DoesBindFilePathExist(ctx, *req.FilePath, bindFileTopology.UUID, ""); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> if nameExists </span><span class="cov8" title="1">{
                return "", utils.ErrorBindFileExists
        }</span>

        <span class="cov8" title="1">if err := s.saveBindFile(topologyId, *req.FilePath, *req.Content); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">newUuid := utils.GenerateUuid()
        err = s.topologyRepo.CreateBindFile(ctx, &amp;BindFile{
                UUID:     newUuid,
                FilePath: *req.FilePath,
                Topology: *bindFileTopology,
        })

        return newUuid, err</span>
}

func (s *topologyService) UpdateBindFile(ctx *gin.Context, req BindFileInPartial, bindFileUuid string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        bindFile, err := s.topologyRepo.GetBindFileByUuid(ctx, bindFileUuid)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">bindFileTopology, err := s.topologyRepo.GetByUuid(ctx, bindFile.Topology.UUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deny request if user does not have access to the owning topology
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != bindFileTopology.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToBindFile
        }</span>

        <span class="cov8" title="1">bindFilePath := bindFile.FilePath

        if req.FilePath != nil </span><span class="cov8" title="1">{
                // Don't allow duplicate bind file names within the same topology
                if nameExists, err := s.topologyRepo.DoesBindFilePathExist(ctx, *req.FilePath, bindFileTopology.UUID, bindFileUuid); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if nameExists </span><span class="cov8" title="1">{
                        return utils.ErrorBindFileExists
                }</span>

                // Delete old file if file path has changed
                <span class="cov8" title="1">if bindFile.FilePath != *req.FilePath </span><span class="cov8" title="1">{
                        if err := s.removeBindFile(bindFileTopology.UUID, bindFile.FilePath); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Failed to delete old bind file '%s': %s", bindFile.FilePath, err.Error())
                        }</span>
                }

                <span class="cov8" title="1">bindFilePath = *req.FilePath</span>
        } else<span class="cov8" title="1"> {
                return utils.ErrorInvalidBindFilePath
        }</span>

        <span class="cov8" title="1">var bindFileContent string
        if req.Content != nil </span><span class="cov8" title="1">{
                bindFileContent = *req.Content
        }</span> else<span class="cov0" title="0"> {
                bindFileOut, err := s.loadBindFile(bindFileTopology.UUID, *bindFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">bindFileContent = bindFileOut.Content</span>
        }

        <span class="cov8" title="1">if err := s.saveBindFile(bindFileTopology.UUID, bindFilePath, bindFileContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bindFile.FilePath = bindFilePath

        return s.topologyRepo.UpdateBindFile(ctx, bindFile)</span>
}

func (s *topologyService) DeleteBindFile(ctx *gin.Context, bindFileId string, authUser auth.AuthenticatedUser) error <span class="cov8" title="1">{
        bindFile, err := s.topologyRepo.GetBindFileByUuid(ctx, bindFileId)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">bindFileTopology, err := s.topologyRepo.GetByUuid(ctx, bindFile.Topology.UUID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Deny request if user does not have access to the owning topology
        <span class="cov8" title="1">if !authUser.IsAdmin &amp;&amp; authUser.UserId != bindFileTopology.Creator.UUID </span><span class="cov8" title="1">{
                return utils.ErrorNoWriteAccessToBindFile
        }</span>

        <span class="cov8" title="1">if err := s.removeBindFile(bindFileTopology.UUID, bindFile.FilePath); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to delete bind file '%s': %s", bindFile.FilePath, err.Error())
        }</span>

        <span class="cov8" title="1">return s.topologyRepo.DeleteBindFile(ctx, bindFile)</span>
}

func (s *topologyService) validateTopology(definition string) error <span class="cov8" title="1">{
        var definitionObj any

        if err := yaml.Unmarshal([]byte(definition), &amp;definitionObj); err != nil </span><span class="cov8" title="1">{
                return utils.ErrorInvalidTopology
        }</span>

        <span class="cov8" title="1">if err := s.schemaLoader.Validate(definitionObj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *topologyService) saveTopology(topologyId string, definition string) error <span class="cov8" title="1">{
        if err := s.storageManager.WriteTopology(topologyId, definition); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to write topology definition for %s: %s", topologyId, err.Error())
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *topologyService) LoadTopology(topologyId string, bindFiles []BindFile) (string, []BindFileOut, error) <span class="cov8" title="1">{
        var definition string

        if err := s.storageManager.ReadTopology(topologyId, &amp;definition); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to read topology definition for %s: %s", topologyId, err.Error())
                return "", nil, err
        }</span>

        <span class="cov8" title="1">bindFilesOut := make([]BindFileOut, 0)
        for _, bindFile := range bindFiles </span><span class="cov8" title="1">{
                bindFileOut, err := s.loadBindFile(topologyId, bindFile)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, err
                }</span>

                <span class="cov8" title="1">bindFilesOut = append(bindFilesOut, *bindFileOut)</span>
        }

        <span class="cov8" title="1">return definition, bindFilesOut, nil</span>
}

func (s *topologyService) loadBindFile(topologyId string, bindFile BindFile) (*BindFileOut, error) <span class="cov8" title="1">{
        var fileContent string
        if err := s.storageManager.ReadBindFile(topologyId, bindFile.FilePath, &amp;fileContent); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to read bind file '%s' for '%s': %s", bindFile.FilePath, topologyId, err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">bindFileOut := s.topologyRepo.BindFileToOut(bindFile, fileContent)

        return &amp;bindFileOut, nil</span>
}

func (s *topologyService) removeBindFile(topologyId string, filePath string) error <span class="cov8" title="1">{
        if err := s.storageManager.DeleteBindFile(topologyId, filePath); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to delete bind file '%s' for '%s': %s", filePath, topologyId, err.Error())
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *topologyService) saveBindFile(topologyId string, filePath string, fileContent string) error <span class="cov8" title="1">{
        if err := s.storageManager.WriteBindFile(topologyId, filePath, fileContent); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to write bind file '%s' for '%s': %s", filePath, topologyId, err.Error())
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *topologyService) getNameFromDefinition(definitionString string) string <span class="cov8" title="1">{
        var topologyDefinition struct {
                Name string `yaml:"name"`
        }
        _ = yaml.Unmarshal([]byte(definitionString), &amp;topologyDefinition)

        return topologyDefinition.Name
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package user

import (
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
        "net/http"
)

type (
        Handler interface {
                AuthConfig(ctx *gin.Context)
                Logout(ctx *gin.Context)
                LoginOpenId(ctx *gin.Context)
                LoginNative(ctx *gin.Context)
                LoginOpenIdSuccess(ctx *gin.Context)
                RefreshToken(ctx *gin.Context)
        }

        userHandler struct {
                userService Service
        }
)

func CreateHandler(userService Service) Handler <span class="cov8" title="1">{
        return &amp;userHandler{
                userService: userService,
        }
}</span>

// @Summary        Authenticate via native login
// @Accept                json
// @Tags                users
// @Success        200                {object}        nil
//
// @Failure        400                {object}        nil                                "The provided credentials were invalid"
// @Failure        401                {object}        nil                                "Authentication via native login is disabled"
// @Param                request        body                CredentialsIn        true        "The native credentials"
// @Router                /users/login/native [get]
func (h *userHandler) LoginNative(ctx *gin.Context) <span class="cov8" title="1">{
        payload := CredentialsIn{}
        if err := ctx.Bind(&amp;payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(utils.ErrorInvalidCredentials))
                return
        }</span>

        <span class="cov8" title="1">if refreshToken, accessToken, err := h.userService.LoginNative(payload); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(err))
        }</span> else<span class="cov8" title="1"> {
                ctx.SetCookie("authToken", refreshToken, 0, "/", "", false, true)
                ctx.SetCookie("accessToken", accessToken, 0, "/", "", false, false)
        }</span>
}

// @Summary        Authenticate via OpenID provider. Redirects the client to the OpenID provider page.
// @Accept                json
// @Tags                users
// @Success        302        {object}        nil
// @Failure        401        {object}        nil        "Authentication via OpenID is disabled"
// @Router                /users/login/openid [get]
func (h *userHandler) LoginOpenId(ctx *gin.Context) <span class="cov0" title="0">{
        url, err := h.userService.GetAuthCodeURL(ctx.Request.Referer())
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov0" title="0">http.Redirect(ctx.Writer, ctx.Request, url, http.StatusFound)</span>
}

// @Summary        Redirect URL for the OpenID provider.
func (h *userHandler) LoginOpenIdSuccess(ctx *gin.Context) <span class="cov0" title="0">{
        authToken, accessToken, err := h.userService.AuthenticateWithCode(ctx, ctx.Query("code"))
        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(utils.CreateErrorResponse(err))
                return
        }</span>

        <span class="cov0" title="0">ctx.SetCookie("authToken", authToken, 0, "/", "", false, true)
        ctx.SetCookie("authOidc", "true", 0, "/", "", false, false)
        ctx.SetCookie("accessToken", accessToken, 0, "/", "", false, false)

        http.Redirect(ctx.Writer, ctx.Request, ctx.Query("state"), http.StatusFound)</span>
}

// @Summary        Logout and clear all authentication cookies
// @Tags                users
// @Success        200        {object}        nil
// @Router                /users/logout [post]
func (h *userHandler) Logout(ctx *gin.Context) <span class="cov8" title="1">{
        ctx.SetCookie("authToken", "", -1, "/", "", false, true)
        ctx.SetCookie("authOidc", "", -1, "/", "", false, false)
        ctx.SetCookie("accessToken", "", -1, "/", "", false, false)
}</span>

// @Summary        Get the server's authentication config
// @Accept                json
// @Produce        json
// @Tags                users
// @Success        200        {object}        utils.OkResponse[auth.AuthConfig]        "The authentication config of the server"
// @Router                /users/login/config [get]
func (h *userHandler) AuthConfig(ctx *gin.Context) <span class="cov8" title="1">{
        ctx.JSON(utils.CreateOkResponse(h.userService.GetAuthConfig()))
}</span>

// @Summary        Refresh the access token
// @Tags                users
// @Success        200        {object}        utils.OkResponse[auth.AuthConfig]        "The authentication config of the server"
// @Failure        401        {object}        nil                                                                        "The auth token cookie is not set"
// @Failure        403        {object}        nil                                                                        "The provided auth token was invalid"
// @Router                /users/login/refresh [get]
func (h *userHandler) RefreshToken(ctx *gin.Context) <span class="cov8" title="1">{
        var (
                authToken, accessToken string
                err                    error
        )

        if authToken, err = ctx.Cookie("authToken"); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(utils.ErrorUnauthorized))
                return
        }</span>

        <span class="cov8" title="1">if accessToken, err = h.userService.RefreshAccessToken(authToken); err != nil </span><span class="cov8" title="1">{
                ctx.JSON(utils.CreateErrorResponse(utils.ErrorForbidden))
                return
        }</span>

        <span class="cov8" title="1">ctx.SetCookie("accessToken", accessToken, 0, "/", "", false, false)

        ctx.JSON(utils.CreateOkResponse(accessToken))</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package user

import (
        "antimonyBackend/utils"
        "context"
        "github.com/charmbracelet/log"
        "gorm.io/gorm"
)

type (
        Repository interface {
                GetByUuid(ctx context.Context, userId string) (*User, error)
                GetBySub(ctx context.Context, openId string) (*User, bool, error)

                Create(ctx context.Context, user *User) error
                Update(ctx context.Context, user *User) error

                UserToOut(user User) UserOut
        }

        userRepository struct {
                db *gorm.DB
        }
)

func CreateRepository(db *gorm.DB) Repository <span class="cov8" title="1">{
        return &amp;userRepository{
                db: db,
        }
}</span>

func (r *userRepository) GetByUuid(ctx context.Context, userId string) (*User, error) <span class="cov8" title="1">{
        var user User
        result := r.db.WithContext(ctx).Where("uuid = ?", userId).Limit(1).Find(&amp;user)

        if result.RowsAffected &lt; 1 </span><span class="cov8" title="1">{
                return nil, utils.ErrorUuidNotFound
        }</span>

        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to fetch user by UUID. Error: %s", result.Error.Error())
                return nil, utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *userRepository) GetBySub(ctx context.Context, userSub string) (*User, bool, error) <span class="cov0" title="0">{
        var user User
        result := r.db.WithContext(ctx).
                Limit(1).
                Find(&amp;user, "sub = ?", userSub)

        if result.Error != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to get user by sub. Error: %s", result.Error.Error())
                return nil, false, utils.ErrorDatabaseError
        }</span>

        <span class="cov0" title="0">return &amp;user, result.RowsAffected &gt; 0, nil</span>
}

func (r *userRepository) Update(ctx context.Context, user *User) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Save(user).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to update user. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *userRepository) Create(ctx context.Context, user *User) error <span class="cov8" title="1">{
        if err := r.db.WithContext(ctx).Create(user).Error; err != nil </span><span class="cov0" title="0">{
                log.Errorf("[DB] Failed to create user. Error: %s", err.Error())
                return utils.ErrorDatabaseError
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *userRepository) UserToOut(user User) UserOut <span class="cov8" title="1">{
        return UserOut{
                ID:   user.UUID,
                Name: user.Name,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package user

import (
        "github.com/gin-gonic/gin"
)

func RegisterRoutes(route *gin.Engine, handler Handler) <span class="cov8" title="1">{
        routes := route.Group("/users")
        </span><span class="cov8" title="1">{
                routes.POST("/logout", handler.Logout)
                routes.POST("/login/native", handler.LoginNative)
                routes.GET("/login/openid", handler.LoginOpenId)
                routes.GET("/login/config", handler.AuthConfig)
                routes.GET("/login/success", handler.LoginOpenIdSuccess)
                routes.GET("/login/refresh", handler.RefreshToken)
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package user

import (
        "antimonyBackend/auth"
        "antimonyBackend/utils"
        "context"
        "errors"
        "github.com/charmbracelet/log"
        "github.com/gin-gonic/gin"
)

type (
        Service interface {
                GetByUuid(ctx context.Context, userId string) (*User, error)
                GetAuthCodeURL(stateToken string) (string, error)
                LoginNative(req CredentialsIn) (string, string, error)
                IsTokenValid(accessToken string) bool
                RefreshAccessToken(authToken string) (string, error)
                AuthenticateWithCode(ctx *gin.Context, authCode string) (string, string, error)
                GetAuthConfig() auth.AuthConfig
        }

        userService struct {
                userRepo    Repository
                authManager auth.AuthManager
        }
)

func CreateService(userRepo Repository, authManager auth.AuthManager) Service <span class="cov8" title="1">{
        userService := &amp;userService{
                userRepo:    userRepo,
                authManager: authManager,
        }

        if _, err := userRepo.GetByUuid(context.Background(), auth.NativeUserID); errors.Is(err, utils.ErrorUuidNotFound) </span><span class="cov8" title="1">{
                nativeUser := &amp;User{
                        UUID: auth.NativeUserID,
                        Sub:  "Admin",
                        Name: "Admin",
                }
                if err := userRepo.Create(context.Background(), nativeUser); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to register native user in database")
                }</span>
        }

        <span class="cov8" title="1">return userService</span>
}

func (s *userService) IsTokenValid(accessToken string) bool <span class="cov0" title="0">{
        _, err := s.authManager.AuthenticateUser(accessToken)
        return err == nil
}</span>

func (s *userService) RefreshAccessToken(authToken string) (string, error) <span class="cov8" title="1">{
        return s.authManager.RefreshAccessToken(authToken)
}</span>

func (s *userService) GetByUuid(ctx context.Context, userId string) (*User, error) <span class="cov0" title="0">{
        return s.userRepo.GetByUuid(ctx, userId)
}</span>

func (s *userService) LoginNative(req CredentialsIn) (string, string, error) <span class="cov8" title="1">{
        return s.authManager.LoginNative(req.Username, req.Password)
}</span>

func (s *userService) GetAuthCodeURL(stateToken string) (string, error) <span class="cov0" title="0">{
        return s.authManager.GetAuthCodeURL(stateToken)
}</span>

func (s *userService) AuthenticateWithCode(ctx *gin.Context, authCode string) (string, string, error) <span class="cov8" title="1">{
        authUser, err := s.authManager.AuthenticateWithCode(authCode, func(userSub string, userProfile string) (string, error) </span><span class="cov8" title="1">{
                var (
                        user       *User
                        userExists bool
                        err        error
                )

                if user, userExists, err = s.userRepo.GetBySub(ctx, userSub); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">if !userExists </span><span class="cov8" title="1">{
                        // Create the user if not registered yet
                        user = &amp;User{
                                UUID: utils.GenerateUuid(),
                                Sub:  userSub,
                                Name: userProfile,
                        }
                        err = s.userRepo.Create(ctx, user)
                }</span> else<span class="cov8" title="1"> {
                        // Update the name of the user in case it has changed
                        user.Name = userProfile
                        err = s.userRepo.Update(ctx, user)
                }</span>

                <span class="cov8" title="1">return user.UUID, err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if authToken, err := s.authManager.CreateAuthToken(authUser.UserId); err != nil </span><span class="cov8" title="1">{
                return "", "", err
        }</span> else<span class="cov8" title="1"> if accessToken, err := s.authManager.CreateAccessToken(*authUser); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span> else<span class="cov8" title="1"> {
                return authToken, accessToken, nil
        }</span>
}

func (s *userService) GetAuthConfig() auth.AuthConfig <span class="cov8" title="1">{
        return s.authManager.GetAuthConfig()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package events

import (
        "slices"
)

type (
        Event[T any] interface {
                Dispatch(value T)
                Subscribe(*func(value T))
                Unsubscribe(*func(value T))
        }

        event[T any] struct {
                listeners []*func(value T)
        }
)

func CreateEvent[T any]() Event[T] <span class="cov0" title="0">{
        return &amp;event[T]{
                listeners: make([]*func(data T), 0),
        }
}</span>

func (m event[T]) Dispatch(value T) <span class="cov0" title="0">{
        for _, listener := range m.listeners </span><span class="cov0" title="0">{
                (*listener)(value)
        }</span>
}

func (m event[T]) Subscribe(f *func(data T)) <span class="cov0" title="0">{
        m.listeners = append(m.listeners, f)
}</span>

func (m event[T]) Unsubscribe(f *func(data T)) <span class="cov0" title="0">{
        if index := slices.Index(m.listeners, f); index &gt; -1 </span><span class="cov0" title="0">{
                m.listeners = append(m.listeners[:index], m.listeners[index+1:]...)
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package main

import (
        "antimonyBackend/auth"
        "antimonyBackend/config"
        _ "antimonyBackend/docs"
        "antimonyBackend/domain/collection"
        "antimonyBackend/domain/device"
        "antimonyBackend/domain/lab"
        "antimonyBackend/domain/schema"
        "antimonyBackend/domain/statusMessage"
        "antimonyBackend/domain/topology"
        "antimonyBackend/domain/user"
        "antimonyBackend/socket"
        "antimonyBackend/storage"
        "antimonyBackend/utils"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/charmbracelet/log"
        "github.com/gin-gonic/gin"
        "github.com/glebarez/sqlite"
        "github.com/joho/godotenv"
        "github.com/swaggo/files"
        "github.com/swaggo/gin-swagger"
        socketio "github.com/zishang520/socket.io/socket"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

//        @Title                Antimony API
//        @Version        1.0
//        @Desciption        The Antimony API that connects to containerlab.

//        @Contact.name        Institute for Networking at OST
//        @Contact.url        https://www.ost.ch/en/research-and-consulting-services/computer-science/ins-institute-for-network-and-security
//        @Contact.email        antimony@network.garden

//        @BasePath        /api/v1

// @securityDefinitions.basic        BasicAuth
func main() <span class="cov0" title="0">{
        // Load environment variables from .env file if present
        _ = godotenv.Load()

        cmdArgs := utils.ParseArguments()
        isDevMode := *cmdArgs.DevelopmentMode

        log.SetTimeFormat("[2006-01-02 15:04:05]")

        if isDevMode </span><span class="cov0" title="0">{
                log.SetReportCaller(true)
        }</span>

        <span class="cov0" title="0">antimonyConfig := config.Load(*cmdArgs.ConfigFile)
        authManager := auth.CreateAuthManager(antimonyConfig)
        storageManager := storage.CreateStorageManager(antimonyConfig)

        db := connectToDatabase(*cmdArgs.UseLocalDatabase, antimonyConfig)
        //test.GenerateTestData(db, storageManager)

        socketManager := socket.CreateSocketManager(authManager)

        statusMessageNamespace := socket.CreateOutputNamespace[statusMessage.StatusMessage](
                socketManager, false, false, nil, "status-messages",
        )

        var (
                devicesService = device.CreateService(antimonyConfig)
                devicesHandler = device.CreateHandler(devicesService)

                schemaService = schema.CreateService(antimonyConfig)
                schemaHandler = schema.CreateHandler(schemaService)

                userRepository = user.CreateRepository(db)
                userService    = user.CreateService(userRepository, authManager)
                userHandler    = user.CreateHandler(userService)

                collectionRepository = collection.CreateRepository(db)
                collectionService    = collection.CreateService(collectionRepository, userRepository)
                collectionHandler    = collection.CreateHandler(collectionService)

                topologyRepository = topology.CreateRepository(db)
                topologyService    = topology.CreateService(
                        topologyRepository, userRepository, collectionRepository,
                        storageManager, schemaService.Get(),
                )
                topologyHandler = topology.CreateHandler(topologyService)

                labRepository = lab.CreateRepository(db)
                labService    = lab.CreateService(
                        antimonyConfig, labRepository, userRepository, topologyRepository, topologyService,
                        storageManager, socketManager, statusMessageNamespace,
                )
                labHandler = lab.CreateHandler(labService)
        )

        go labService.RunScheduler()
        go labService.RunShellManager()
        go labService.ListenToProviderEvents()

        gin.SetMode(gin.ReleaseMode)
        webServer := gin.Default()

        // Public endpoints
        user.RegisterRoutes(webServer, userHandler)
        schema.RegisterRoutes(webServer, schemaHandler)

        // Authenticated endpoints
        lab.RegisterRoutes(webServer, labHandler, authManager)
        device.RegisterRoutes(webServer, devicesHandler, authManager)
        topology.RegisterRoutes(webServer, topologyHandler, authManager)
        collection.RegisterRoutes(webServer, collectionHandler, authManager)

        // Register Socket.IO endpoints in web server
        c := socketio.DefaultServerOptions()
        webServer.GET("/socket.io/*any", gin.WrapH(socketManager.Server().ServeHandler(c)))
        webServer.POST("/socket.io/*any", gin.WrapH(socketManager.Server().ServeHandler(c)))

        webServer.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        var serverWaitGroup sync.WaitGroup
        connection := fmt.Sprintf("%s:%d", antimonyConfig.Server.Host, antimonyConfig.Server.Port)

        serverWaitGroup.Add(1)
        go startWebServer(webServer, connection, &amp;serverWaitGroup)
        time.Sleep(100)

        log.Info("Antimony API is ready to serve calls!", "conn", connection)
        serverWaitGroup.Wait()</span>
}

func connectToDatabase(useLocalDatabase bool, config *config.AntimonyConfig) *gorm.DB <span class="cov0" title="0">{
        var (
                db  *gorm.DB
                err error
        )

        if useLocalDatabase </span><span class="cov0" title="0">{
                log.Info("Connecting to local SQLite database", "path", config.Database.LocalFile)
                if err := os.MkdirAll(filepath.Dir(config.Database.LocalFile), 0755); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Failed to create database file", "path", config.Database.Database)
                }</span>
                <span class="cov0" title="0">db, err = gorm.Open(sqlite.Open(config.Database.LocalFile), &amp;gorm.Config{})</span>
        } else<span class="cov0" title="0"> {
                connection := fmt.Sprintf("%s@%s:%d/%s", config.Database.User, config.Database.Host, config.Database.Port, config.Database.Database)
                log.Info("Connecting to remote PostgreSQL database", "conn", connection)

                dsn := fmt.Sprintf(
                        "host=%s user=%s password=%s dbname=%s port=%d",
                        config.Database.Host,
                        config.Database.User,
                        os.Getenv("SB_DATABASE_PASSWORD"),
                        config.Database.Database,
                        config.Database.Port,
                )
                db, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %s", err.Error())
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">err = db.AutoMigrate(&amp;lab.Lab{})
        err = db.AutoMigrate(&amp;user.User{})
        err = db.AutoMigrate(&amp;topology.BindFile{})
        err = db.AutoMigrate(&amp;topology.Topology{})
        err = db.AutoMigrate(&amp;collection.Collection{})

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to migrate table to database: %s", err.Error())
        }</span>

        <span class="cov0" title="0">return db</span>
}

func startWebServer(server *gin.Engine, socket string, waitGroup *sync.WaitGroup) <span class="cov0" title="0">{
        defer waitGroup.Done()

        if err := server.Run(socket); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start web server on %s: %s", socket, err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package socket

import (
        "antimonyBackend/auth"
        "antimonyBackend/utils"
        "context"
        "encoding/json"
        "github.com/charmbracelet/log"
        "github.com/samber/lo"
        socketio "github.com/zishang520/socket.io/socket"
        "slices"
        "strings"
        "sync"
)

type (
        // Manages the dataflow in a socket.io namespace and the clients that are subscribed to it.
        //
        // The namespace can either be anonymous or authenticated. If authenticated, subscribing requires the clients
        // to provide a valid access token which will be used to authenticate them via auth.AuthManager.
        IONamespace[I any, O any] interface {
                // Send Sends a message to all connected clients. This works in authenticated and anonymous namespaces.
                Send(msg O)

                // SendTo Sends a message to a set of user IDs. This only works in authenticated namespaces.
                SendTo(msg O, receivers []string)

                // SendToAdmins Sends a message to all connected admins. This only works in authenticated namespaces.
                SendToAdmins(msg O)

                // ClearBacklog Removes all messages from the backlog
                ClearBacklog()
        }

        InputNamespace[I any]  = IONamespace[I, any]
        OutputNamespace[O any] = IONamespace[any, O]

        namespaceManager[I any, O any] struct {
                // A list of all connected clients, authenticated and anonymous clients
                connectedClients []*SocketConnectedUser

                // A map of all connected authenticated clients indexed by their user ID
                connectedClientsMap   map[string]*SocketConnectedUser
                connectedClientsMutex sync.Mutex

                useRawInput   bool
                isAnonymous   bool
                socketManager SocketManager

                onData DataInputHandler[I]

                // The backlog of previously sent messages
                backlog      []O
                backlogMutex sync.Mutex
                useBacklog   bool

                namespaceName string
                namespace     socketio.NamespaceInterface
        }

        DataInputHandler[I any] func(
                ct context.Context,
                data *I,
                authUser *auth.AuthenticatedUser,
                onResponse func(response utils.OkResponse[any]),
                onError func(response utils.ErrorResponse),
        )
)

// CreateNamespace Creates a new socket.io namespace for a given socket manager.
// The namespace can be anonymous, meaning that users don't need to authenticate themselves when connecting.
// In anonymous namespaces, NamespaceManager.SendTo and NamespaceManager.SendToAdmins aren't available.
//
// If a backlog is used, new clients will receive all previously sent messages via the 'backlog' event upon connecting.
//
// Optionally, one can provide a onData callback which is called whenever a client sends a 'data' event in the namespace.
// The namespace path will be concatenated with slashes to form the namespace name (e.g. [foo, bar] -&gt; /foo/bar).
func CreateIONamespace[I any, O any](
        socketManager SocketManager,
        isAnonymous bool,
        useBacklog bool,
        onData DataInputHandler[I],
        accessGroup *[]*auth.AuthenticatedUser,
        namespacePath ...string,
) IONamespace[I, O] <span class="cov8" title="1">{
        var useRawInput bool

        var test any = *new(I)
        switch test.(type) </span>{
        case string:<span class="cov8" title="1">
                useRawInput = true</span>
        default:<span class="cov8" title="1">
                useRawInput = false</span>
        }

        <span class="cov8" title="1">manager := &amp;namespaceManager[I, O]{
                connectedClients:      make([]*SocketConnectedUser, 0),
                connectedClientsMap:   make(map[string]*SocketConnectedUser),
                connectedClientsMutex: sync.Mutex{},
                socketManager:         socketManager,
                backlog:               make([]O, 0),
                backlogMutex:          sync.Mutex{},
                onData:                onData,
                isAnonymous:           isAnonymous,
                useBacklog:            useBacklog,
                useRawInput:           useRawInput,
        }

        manager.namespaceName = "/" + strings.Join(namespacePath, "/")
        manager.namespace = socketManager.Server().Of(manager.namespaceName, nil)

        if !isAnonymous </span><span class="cov8" title="1">{
                manager.namespace.Use(socketManager.SocketAuthenticatorMiddleware(accessGroup))
        }</span>

        <span class="cov8" title="1">_ = manager.namespace.On("connection", manager.handleConnection)

        return manager</span>
}

func CreateInputNamespace[I any](
        socketManager SocketManager,
        isAnonymous bool,
        useBacklog bool,
        onData DataInputHandler[I],
        accessGroup *[]*auth.AuthenticatedUser,
        namespacePath ...string,
) InputNamespace[I] <span class="cov8" title="1">{
        return CreateIONamespace[I, any](socketManager, isAnonymous, useBacklog, onData, accessGroup, namespacePath...)
}</span>

func CreateOutputNamespace[O any](
        socketManager SocketManager,
        isAnonymous bool,
        useBacklog bool,
        accessGroup *[]*auth.AuthenticatedUser,
        namespacePath ...string,
) OutputNamespace[O] <span class="cov8" title="1">{
        return CreateIONamespace[any, O](socketManager, isAnonymous, useBacklog, nil, accessGroup, namespacePath...)
}</span>

func (m *namespaceManager[I, O]) ClearBacklog() <span class="cov0" title="0">{
        m.backlogMutex.Lock()
        m.backlog = make([]O, 0)
        m.backlogMutex.Unlock()
}</span>

func (m *namespaceManager[I, O]) Send(msg O) <span class="cov8" title="1">{
        m.sendTo(msg, m.connectedClients)
}</span>

func (m *namespaceManager[I, O]) SendTo(msg O, receivers []string) <span class="cov0" title="0">{
        if m.isAnonymous </span><span class="cov0" title="0">{
                log.Errorf("Server is trying to send an addressed socket message in an anonymous namespace. Aborting.")
                return
        }</span>

        <span class="cov0" title="0">m.sendTo(msg, lo.FilterMap(receivers, func(userId string, _ int) (*SocketConnectedUser, bool) </span><span class="cov0" title="0">{
                if client, ok := m.connectedClientsMap[userId]; ok </span><span class="cov0" title="0">{
                        return client, true
                }</span>
                <span class="cov0" title="0">return nil, false</span>
        }))
}

func (m *namespaceManager[I, O]) SendToAdmins(msg O) <span class="cov0" title="0">{
        if m.isAnonymous </span><span class="cov0" title="0">{
                log.Errorf("Server is trying to send an addressed socket message in an anonymous namespace. Aborting.")
                return
        }</span>

        <span class="cov0" title="0">m.sendTo(msg, lo.Filter(m.connectedClients, func(client *SocketConnectedUser, _ int) bool </span><span class="cov0" title="0">{
                return client.IsAdmin
        }</span>))
}

func (m *namespaceManager[I, O]) sendTo(msg O, receivers []*SocketConnectedUser) <span class="cov8" title="1">{
        if m.useBacklog </span><span class="cov8" title="1">{
                m.backlogMutex.Lock()
                m.backlog = append(m.backlog, msg)
                m.backlogMutex.Unlock()
        }</span>

        <span class="cov8" title="1">for _, client := range receivers </span><span class="cov0" title="0">{
                if err := client.socket.Emit("data", msg); err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Failed to emit socket message to client : %s", err.Error())
                }</span>
        }
}

func (m *namespaceManager[I, O]) handleConnection(clients ...any) <span class="cov0" title="0">{
        client := clients[0].(*socketio.Socket)

        if m.isAnonymous </span><span class="cov0" title="0">{
                socketClient := &amp;SocketConnectedUser{
                        AuthenticatedUser: nil,
                        socket:            client,
                }

                m.connectedClientsMutex.Lock()
                m.connectedClients = append(m.connectedClients, socketClient)
                m.connectedClientsMutex.Unlock()

                _ = client.On("disconnect", func(clients ...any) </span><span class="cov0" title="0">{
                        log.Info("Anonymous user disconnected from socket namespace", "namespace", m.namespaceName)

                        if i := slices.Index(m.connectedClients, socketClient); i &gt; -1 </span><span class="cov0" title="0">{
                                m.connectedClientsMutex.Lock()
                                m.connectedClients = append(m.connectedClients[:i], m.connectedClients[i+1:]...)
                                m.connectedClientsMutex.Unlock()
                        }</span>
                })

                <span class="cov0" title="0">log.Info("Anonymous user connected to socket namespace", "namespace", m.namespaceName)
                return</span>
        }

        <span class="cov0" title="0">var authUser *auth.AuthenticatedUser
        if accessToken, ok := client.Handshake().Auth.(map[string]any)["token"].(string); !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> if authUser = m.socketManager.GetAuthUser(accessToken); authUser == nil </span><span class="cov0" title="0">{
                // This is just for consistency, as non-authenticated users should never make it past the middleware
                return
        }</span>

        <span class="cov0" title="0">socketClient := &amp;SocketConnectedUser{
                AuthenticatedUser: authUser,
                socket:            client,
        }

        m.connectedClientsMutex.Lock()
        m.connectedClients = append(m.connectedClients, socketClient)
        m.connectedClientsMap[authUser.UserId] = socketClient
        m.connectedClientsMutex.Unlock()

        _ = client.On("data", func(raw ...any) </span><span class="cov0" title="0">{
                m.handleData(authUser, raw...)
        }</span>)

        <span class="cov0" title="0">_ = client.On("disconnect", func(clients ...any) </span><span class="cov0" title="0">{
                log.Info("User disconnected from socket namespace", "namespace", m.namespaceName, "user", authUser.UserId)

                m.connectedClientsMutex.Lock()
                if i := slices.Index(m.connectedClients, socketClient); i &gt; -1 </span><span class="cov0" title="0">{
                        m.connectedClients = append(m.connectedClients[:i], m.connectedClients[i+1:]...)
                }</span>
                <span class="cov0" title="0">delete(m.connectedClientsMap, authUser.UserId)
                m.connectedClientsMutex.Unlock()</span>
        })

        <span class="cov0" title="0">log.Info("User connected to socket namespace", "namespace", m.namespaceName, "user", authUser.UserId)

        // Immediately send backlog to user if backlog is used in namespace
        if m.useBacklog </span><span class="cov0" title="0">{
                _ = client.Emit("backlog", m.backlog)
        }</span>
}

func (m *namespaceManager[I, O]) handleData(authUser *auth.AuthenticatedUser, raw ...any) <span class="cov0" title="0">{
        var ack func([]any, error)
        if len(raw) &gt; 1 </span><span class="cov0" title="0">{
                ack = raw[1].(func([]any, error))
        }</span>

        <span class="cov0" title="0">dataRaw := raw[0].(string)
        var data I

        if m.useRawInput </span><span class="cov0" title="0">{
                data = any(dataRaw).(I)
        }</span> else<span class="cov0" title="0"> {
                if err := json.Unmarshal([]byte(dataRaw), &amp;data); err != nil </span><span class="cov0" title="0">{
                        if ack != nil </span><span class="cov0" title="0">{
                                errorResponse := utils.CreateSocketErrorResponse(utils.ErrorInvalidSocketRequest)
                                ack([]any{errorResponse}, nil)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">ctx := context.Background()

        if ack != nil </span><span class="cov0" title="0">{
                m.onData(ctx, &amp;data, authUser,
                        func(response utils.OkResponse[any]) </span><span class="cov0" title="0">{
                                ack([]any{response}, nil)
                        }</span>,
                        func(errorResponse utils.ErrorResponse) <span class="cov0" title="0">{
                                ack([]any{errorResponse}, nil)
                        }</span>,
                )
        } else<span class="cov0" title="0"> {
                m.onData(ctx, &amp;data, authUser, nil, nil)
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package socket

import (
        "antimonyBackend/auth"
        "github.com/charmbracelet/log"
        "github.com/samber/lo"
        socketio "github.com/zishang520/socket.io/socket"
        "sync"
)

type (
        // SocketManager Represents a wrapper around the socket.io objects and also manages all authenticated users.
        SocketManager interface {
                // Server A reference to the underlying socket.io server.
                Server() *socketio.Server

                // GetAuthUser Returns an auth user by access token. This can be used by namespace managers to identify
                // an authenticated user sending a message or connecting to a namespace for the first time.
                GetAuthUser(accessToken string) *auth.AuthenticatedUser

                // SocketAuthenticatorMiddleware A middleware function that can be used for authenticated namespaces.
                // Optionally, a group of users that have access to the namespace can be specified. If the list is nil,
                // all authenticated users will have access to the namespace.
                SocketAuthenticatorMiddleware(
                        accessGroup *[]*auth.AuthenticatedUser,
                ) func(s *socketio.Socket, next func(*socketio.ExtendedError))
        }

        socketManager struct {
                server      *socketio.Server
                users       map[string]auth.AuthenticatedUser
                usersMutex  *sync.Mutex
                authManager auth.AuthManager
        }
)

func CreateSocketManager(authManager auth.AuthManager) SocketManager <span class="cov8" title="1">{
        server := socketio.NewServer(nil, nil)

        manager := &amp;socketManager{
                server:      server,
                users:       make(map[string]auth.AuthenticatedUser),
                usersMutex:  &amp;sync.Mutex{},
                authManager: authManager,
        }

        return manager
}</span>

func (m *socketManager) GetAuthUser(accessToken string) *auth.AuthenticatedUser <span class="cov0" title="0">{
        m.usersMutex.Lock()
        defer m.usersMutex.Unlock()

        if authUser, ok := m.users[accessToken]; ok </span><span class="cov0" title="0">{
                return &amp;authUser
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *socketManager) Server() *socketio.Server <span class="cov8" title="1">{
        return m.server
}</span>

func (m *socketManager) SocketAuthenticatorMiddleware(
        accessGroup *[]*auth.AuthenticatedUser,
) func(s *socketio.Socket, next func(*socketio.ExtendedError)) <span class="cov8" title="1">{
        return func(s *socketio.Socket, next func(*socketio.ExtendedError)) </span><span class="cov0" title="0">{
                accessToken := m.parseHandshake(s.Handshake())

                if accessToken == nil </span><span class="cov0" title="0">{
                        next(socketio.NewExtendedError("Unauthorized", nil))
                        return
                }</span>

                <span class="cov0" title="0">authUser, err := m.authManager.AuthenticateUser(*accessToken)
                if err != nil </span><span class="cov0" title="0">{
                        next(socketio.NewExtendedError("Invalid Token", nil))
                        return
                }</span>

                <span class="cov0" title="0">if accessGroup != nil </span><span class="cov0" title="0">{
                        _, hasAccess := lo.Find(*accessGroup, func(accessUser *auth.AuthenticatedUser) bool </span><span class="cov0" title="0">{
                                return authUser.UserId == accessUser.UserId
                        }</span>)

                        <span class="cov0" title="0">if !hasAccess </span><span class="cov0" title="0">{
                                log.Infof("no access")
                                next(socketio.NewExtendedError("No Access", nil))
                                return
                        }</span>
                }

                <span class="cov0" title="0">m.usersMutex.Lock()
                m.users[*accessToken] = *authUser
                m.usersMutex.Unlock()

                next(nil)</span>
        }
}

func (m *socketManager) parseHandshake(handshake *socketio.Handshake) *string <span class="cov0" title="0">{
        authMap, ok := handshake.Auth.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">accessToken, ok := authMap["token"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;accessToken</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package storage

import (
        "antimonyBackend/config"
        "antimonyBackend/utils"
        "fmt"
        "github.com/charmbracelet/log"
        cp "github.com/otiai10/copy"
        "os"
        "path/filepath"
        "sync"
)

type (
        StorageManager interface {
                ReadTopology(topologyId string, content *string) error
                WriteTopology(topologyId string, content string) error
                ReadBindFile(topologyId string, filePath string, content *string) error
                WriteBindFile(topologyId string, filePath string, content string) error
                DeleteBindFile(topologyId string, filePath string) error

                GetRunTopologyFile(labId string) string

                CreateRunEnvironment(topologyId string, labId string, topologyDefinition string, topologyFilePath *string) error
                DeleteRunEnvironment(labId string) error
        }

        storageManager struct {
                storagePath    string
                runPath        string
                fileCache      map[string]string
                fileCacheMutex *sync.Mutex
                copyOptions    cp.Options
        }
)

func CreateStorageManager(config *config.AntimonyConfig) StorageManager <span class="cov8" title="1">{
        storageManager := &amp;storageManager{
                storagePath:    config.FileSystem.Storage,
                runPath:        config.FileSystem.Run,
                fileCache:      make(map[string]string),
                fileCacheMutex: &amp;sync.Mutex{},
                copyOptions: cp.Options{
                        Sync: true,
                },
        }

        storageManager.setupDirectories()
        //storageManager.preloadFiles(config)

        return storageManager
}</span>

func (s *storageManager) CreateRunEnvironment(topologyId string, labId string, topologyDefinition string, topologyFilePath *string) error <span class="cov0" title="0">{
        absoluteStoragePath := filepath.Join(s.storagePath, topologyId)
        absoluteRunPath := filepath.Join(s.runPath, labId)

        if err := cp.Copy(absoluteStoragePath, absoluteRunPath, s.copyOptions); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to create run directory for lab: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">runDefinitionPath := getRunDefinitionFilePath(labId)
        if err := s.writeRun(runDefinitionPath, topologyDefinition); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to write run definition for lab: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">*topologyFilePath = filepath.Join(s.runPath, runDefinitionPath)
        return nil</span>
}

func (s *storageManager) GetRunTopologyFile(labId string) string <span class="cov0" title="0">{
        runDefinitionPath := getRunDefinitionFilePath(labId)
        return filepath.Join(s.runPath, runDefinitionPath)
}</span>

func (s *storageManager) ReadRunTopologyDefinition(labId string, content *string) error <span class="cov0" title="0">{
        return s.readRun(getRunDefinitionFilePath(labId), content)
}</span>

func (s *storageManager) ReadTopology(topologyId string, content *string) error <span class="cov8" title="1">{
        return s.readStorage(getDefinitionFilePath(topologyId), content)
}</span>

func (s *storageManager) WriteTopology(topologyId string, content string) error <span class="cov8" title="1">{
        return s.writeStorage(getDefinitionFilePath(topologyId), content)
}</span>

func (s *storageManager) ReadBindFile(topologyId string, filePath string, content *string) error <span class="cov8" title="1">{
        return s.readStorage(getBindFilePath(topologyId, filePath), content)
}</span>

func (s *storageManager) WriteBindFile(topologyId string, filePath string, content string) error <span class="cov8" title="1">{
        return s.writeStorage(getBindFilePath(topologyId, filePath), content)
}</span>

func (s *storageManager) DeleteBindFile(topologyId string, filePath string) error <span class="cov8" title="1">{
        return s.deleteStorage(getBindFilePath(topologyId, filePath))
}</span>

func (s *storageManager) DeleteRunEnvironment(labId string) error <span class="cov8" title="1">{
        return s.deleteRun(labId)
}</span>

func (s *storageManager) setupDirectories() <span class="cov8" title="1">{
        if _, err := os.ReadDir(s.storagePath); err != nil || !utils.IsDirectoryWritable(s.storagePath) </span><span class="cov0" title="0">{
                log.Info("Storage directory not found. Creating.", "dir", s.storagePath)
                if err = os.MkdirAll(s.storagePath, 0755); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Storage directory is not accessible. Exiting.", "dir", s.storagePath)
                        return
                }</span>
        }

        <span class="cov8" title="1">if _, err := os.ReadDir(s.runPath); err != nil || !utils.IsDirectoryWritable(s.runPath) </span><span class="cov0" title="0">{
                log.Info("Run directory not found. Creating.", "dir", s.runPath)
                if err = os.MkdirAll(s.runPath, 0755); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Run directory is not accessible. Exiting.", "dir", s.runPath)
                        return
                }</span>
        }
}

func (s *storageManager) preloadFiles() <span class="cov0" title="0">{
        files, err := os.ReadDir(s.storagePath)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                log.Info("No files to preload. Skipping.")
                return
        }</span> else<span class="cov0" title="0"> {
                log.Info("Preloading files from storage.", "files", len(files))
        }</span>

        <span class="cov0" title="0">preloadCount := 0
        for _, e := range files </span><span class="cov0" title="0">{
                var content string
                if err := s.read(e.Name(), &amp;content); err != nil </span><span class="cov0" title="0">{
                        filePath := filepath.Join(s.storagePath, e.Name())
                        log.Warnf("Failed to preload storage file '%s': %s", filePath, err.Error())
                        continue</span>
                }
                <span class="cov0" title="0">preloadCount++</span>
        }

        <span class="cov0" title="0">log.Info("Successfully preloaded files from storage.", "files", fmt.Sprintf("%d/%d", preloadCount, len(files)))</span>
}

func (s *storageManager) writeStorage(relativeFilePath string, content string) error <span class="cov8" title="1">{
        return s.write(filepath.Join(s.storagePath, relativeFilePath), content)
}</span>

func (s *storageManager) writeRun(relativeFilePath string, content string) error <span class="cov0" title="0">{
        return s.write(filepath.Join(s.runPath, relativeFilePath), content)
}</span>

func (s *storageManager) readStorage(relativeFilePath string, content *string) error <span class="cov8" title="1">{
        return s.read(filepath.Join(s.storagePath, relativeFilePath), content)
}</span>

func (s *storageManager) readRun(relativeFilePath string, content *string) error <span class="cov0" title="0">{
        return s.read(filepath.Join(s.runPath, relativeFilePath), content)
}</span>

func (s *storageManager) deleteStorage(relativePath string) error <span class="cov8" title="1">{
        return s.delete(filepath.Join(s.storagePath, relativePath))
}</span>

func (s *storageManager) deleteRun(relativePath string) error <span class="cov8" title="1">{
        return s.delete(filepath.Join(s.runPath, relativePath))
}</span>

func (s *storageManager) read(absoluteFilePath string, content *string) error <span class="cov8" title="1">{
        if data, err := os.ReadFile(absoluteFilePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                *content = string(data)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *storageManager) write(absoluteFilePath string, content string) error <span class="cov8" title="1">{
        if _, err := os.ReadDir(filepath.Dir(absoluteFilePath)); err != nil </span><span class="cov8" title="1">{
                if err = os.MkdirAll(filepath.Dir(absoluteFilePath), 0755); err != nil </span><span class="cov0" title="0">{
                        return utils.ErrorFileStorage
                }</span>
        }

        <span class="cov8" title="1">return os.WriteFile(absoluteFilePath, ([]byte)(content), 0755)</span>
}

func (s *storageManager) delete(absolutePath string) error <span class="cov8" title="1">{
        if err := os.RemoveAll(absolutePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getDefinitionFilePath(topologyId string) string <span class="cov8" title="1">{
        return filepath.Join(topologyId, "topology.clab.yaml")
}</span>

func getRunDefinitionFilePath(labId string) string <span class="cov0" title="0">{
        return filepath.Join(labId, "topology.clab.yaml")
}</span>

func getBindFilePath(topologyId string, filePath string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", topologyId, filePath)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package test

import (
        "antimonyBackend/auth"
        "antimonyBackend/config"
        "antimonyBackend/domain/collection"
        "antimonyBackend/domain/device"
        "antimonyBackend/domain/lab"
        "antimonyBackend/domain/schema"
        "antimonyBackend/domain/statusMessage"
        "antimonyBackend/domain/topology"
        "antimonyBackend/domain/user"
        "antimonyBackend/socket"
        "antimonyBackend/storage"
        "antimonyBackend/utils"
        "github.com/gin-gonic/gin"
        "github.com/glebarez/sqlite"
        "github.com/stretchr/testify/assert"
        "gorm.io/gorm"
        "log"
        "os"
        "testing"
        "time"
)

func ptr(t time.Time) *time.Time <span class="cov8" title="1">{ return &amp;t }</span>

func GenerateTestData(db *gorm.DB, storage storage.StorageManager) <span class="cov8" title="1">{
        //db.Exec("DROP TABLE IF EXISTS collections,labs,status_messages,topologies,user_status_messages,users,bind_files")

        user1 := user.User{
                UUID: "test-user-id1",
                Sub:  "doesntmatter",
                Name: "Hans Hlsensack",
        }
        if err := db.Create(&amp;user1).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Create user1 failed: %v", err)
        }</span>
        <span class="cov8" title="1">user2 := user.User{
                UUID: "test-user-id2",
                Sub:  "doesntmatter",
                Name: "Max Muster",
        }
        db.Create(&amp;user2)
        user3 := user.User{
                UUID: "test-user-id3",
                Sub:  "irrelevant",
                Name: "Lu",
        }
        db.Create(&amp;user3)
        user4 := user.User{
                UUID: "test-user-id4",
                Sub:  "irrelevant",
                Name: "Emergency Dner",
        }
        db.Create(&amp;user4)
        user5 := user.User{
                UUID: "test-user-id5",
                Sub:  "irrelevant",
                Name: "Not Authenticated",
        }
        db.Create(&amp;user5)

        db.Create(&amp;collection.Collection{
                UUID:         utils.GenerateUuid(),
                Name:         "hidden-group",
                PublicWrite:  true,
                PublicDeploy: false,
                Creator:      user1,
        })

        db.Create(&amp;collection.Collection{
                UUID:         utils.GenerateUuid(),
                Name:         "fs25-cldinf",
                PublicWrite:  false,
                PublicDeploy: false,
                Creator:      user1,
        })

        db.Create(&amp;collection.Collection{
                UUID:         utils.GenerateUuid(),
                Name:         "fs25-nisec",
                PublicWrite:  true,
                PublicDeploy: false,
                Creator:      user1,
        })

        db.Create(&amp;collection.Collection{
                UUID:         utils.GenerateUuid(),
                Name:         "hs25-cn1",
                PublicWrite:  false,
                PublicDeploy: true,
                Creator:      user1,
        })

        collection1 := collection.Collection{
                UUID:         "CollectionTestUUID1",
                Name:         "hs25-cn2",
                PublicWrite:  true,
                PublicDeploy: true,
                Creator:      user1,
        }
        db.Create(&amp;collection1)

        topology1Uuid := "TopologyTestUUID1"
        topology1 := topology.Topology{
                UUID:       topology1Uuid,
                Name:       "ctd",
                SyncUrl:    "",
                Collection: collection1,
                Creator:    user1,
        }
        if err := db.Create(&amp;topology1).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Create topology failed: %v", err)
        }</span>

        <span class="cov8" title="1">db.Create(&amp;topology.BindFile{
                UUID:       "BindFileTestUUID1",
                FilePath:   "leaf01/interfaces",
                Topology:   topology1,
                TopologyID: topology1.ID,
        })
        db.Create(&amp;topology.BindFile{
                UUID:       utils.GenerateUuid(),
                FilePath:   "leaf01/daemons",
                Topology:   topology1,
                TopologyID: topology1.ID,
        })
        db.Create(&amp;topology.BindFile{
                UUID:       utils.GenerateUuid(),
                FilePath:   "leaf01/frr.conf",
                Topology:   topology1,
                TopologyID: topology1.ID,
        })

        writeTopologyFile(topology1Uuid, cvx03, storage)
        writeBindFile(topology1Uuid, "leaf01/interfaces", "1", storage)
        writeBindFile(topology1Uuid, "leaf01/daemons", "2", storage)
        writeBindFile(topology1Uuid, "leaf01/frr.conf", "3", storage)

        topology2Uuid := utils.GenerateUuid()
        topology2 := topology.Topology{
                UUID:       topology2Uuid,
                Name:       "test1",
                SyncUrl:    "",
                Collection: collection1,
                Creator:    user1,
        }
        db.Create(&amp;topology2)
        writeTopologyFile(topology2Uuid, test1, storage)
        emptyString := "empty"
        lab1 := lab.Lab{
                UUID:               "TestLabUUID1",
                Name:               "Test Lab",
                StartTime:          time.Now().Add(-1 * time.Hour),
                EndTime:            ptr(time.Now().Add(1 * time.Hour)),
                TopologyID:         topology1.ID,
                Topology:           topology1,
                CreatorID:          user1.ID,
                Creator:            user1,
                TopologyDefinition: &amp;emptyString,
        }
        db.Create(&amp;lab1)
        lab2 := lab.Lab{
                UUID:               "TestLabUUID2",
                Name:               "Test Lab2",
                StartTime:          time.Now().Add(-1 * time.Hour),
                EndTime:            ptr(time.Now().Add(1 * time.Hour)),
                TopologyID:         topology1.ID,
                Topology:           topology1,
                CreatorID:          user1.ID,
                Creator:            user1,
                TopologyDefinition: &amp;emptyString,
        }
        db.Create(&amp;lab2)</span>

}

const cvx03 = `name: ctd
topology:
  nodes:
    leaf01:
      kind: nokia_srlinux
      image: networkop/cx:4.3.0
      binds:
        - leaf01/interfaces:/etc/network/interfaces
        - leaf01/daemons:/etc/frr/daemons
        - leaf01/frr.conf:/etc/frr/frr.conf

    leaf02:
      kind: nokia_srlinux
      image: networkop/cx:4.3.0

    spine01:
      kind: nokia_srlinux
      image: networkop/cx:4.3.0

    server01:
      kind: linux
      image: networkop/host:ifreload

    server02:
      kind: linux
      image: networkop/host:ifreload


  links:
    - endpoints: ["leaf01:swp1", "server01:eth1"]
    - endpoints: ["leaf01:swp2", "server02:eth1"]
    - endpoints: ["leaf02:swp1", "server01:eth2"]
    - endpoints: ["leaf02:swp2", "server02:eth2"]

    - endpoints: ["leaf01:swp49", "leaf02:swp49"]
    - endpoints: ["leaf01:swp50", "leaf02:swp50"]

    - endpoints: ["spine01:swp1", "leaf01:swp51"]
    - endpoints: ["spine01:swp2", "leaf02:swp51"]`

const test1 = `name: test1
topology:
  nodes:
    node1:
      kind: nokia_srlinux
      image: ghcr.io/nokia/srlinux

    node2:
      kind: nokia_srlinux
      image: ghcr.io/nokia/srlinux

  links:
    - endpoints: ["node1:e1-1", "node2:e1-1"]`

func writeTopologyFile(topologyId string, content string, storage storage.StorageManager) <span class="cov8" title="1">{
        if err := storage.WriteTopology(topologyId, content); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write test topology: %s", err.Error())
        }</span>
}

func writeBindFile(topologyId string, filePath string, content string, storage storage.StorageManager) <span class="cov8" title="1">{
        if err := storage.WriteBindFile(topologyId, filePath, content); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to write test topology bind file: %s", err.Error())
        }</span>
}

func addAuthenticatedUsers(authManager auth.AuthManager) <span class="cov8" title="1">{
        var err error

        _, err = authManager.RegisterTestUser(auth.AuthenticatedUser{
                UserId:      "test-user-id1",
                IsAdmin:     true,
                Collections: []string{"hidden-group", "fs25-cldinf", "fs25-nisec", "hs25-cn1", "hs25-cn2"},
        })
        _, err = authManager.RegisterTestUser(auth.AuthenticatedUser{
                UserId:      "test-user-id2",
                IsAdmin:     true,
                Collections: []string{},
        })
        _, err = authManager.RegisterTestUser(auth.AuthenticatedUser{
                UserId:      "test-user-id3",
                IsAdmin:     false,
                Collections: []string{"hidden-group", "fs25-cldinf", "fs25-nisec", "hs25-cn1", "hs25-cn2"},
        })
        _, err = authManager.RegisterTestUser(auth.AuthenticatedUser{
                UserId:      "test-user-id4",
                IsAdmin:     false,
                Collections: []string{},
        })
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

func SetupTestServer(t *testing.T) (*gin.Engine, auth.AuthManager, *gorm.DB) <span class="cov8" title="1">{
        gin.SetMode(gin.TestMode)

        // Set environment variables
        _ = os.Setenv("SB_NATIVE_USERNAME", "testuser")
        _ = os.Setenv("SB_NATIVE_PASSWORD", "testpass")

        storageDir := t.TempDir()
        runDir := t.TempDir()
        // Load config manually
        cfg := &amp;config.AntimonyConfig{
                FileSystem: config.FilesystemConfig{
                        Storage: storageDir,
                        Run:     runDir,
                },
                Containerlab: config.ClabConfig{
                        SchemaUrl:      "https://raw.githubusercontent.com/srl-labs/containerlab/refs/heads/main/schemas/clab.schema.json",
                        SchemaFallback: "../../data/clab.schema.json",
                        DeviceConfig:   "../../data/device-config.json",
                },
                Auth: config.AuthConfig{
                        EnableNative:      true,
                        EnableOpenId:      false,
                        OpenIdIssuer:      "",
                        OpenIdClientId:    "",
                        OpenIdAdminGroups: []string{},
                },
        }
        authManager := auth.CreateAuthManager(cfg)
        devicesService := device.CreateService(cfg)
        storageManager := storage.CreateStorageManager(cfg)
        schemaService := schema.CreateService(cfg)

        // Step 4: Setup in-memory DB
        db, err := gorm.Open(sqlite.Open(":memory:"), &amp;gorm.Config{})
        assert.NoError(t, err)

        err = db.AutoMigrate(
                &amp;user.User{},
                &amp;collection.Collection{},
                &amp;topology.Topology{},
                &amp;topology.BindFile{},
                &amp;lab.Lab{},
        )
        assert.NoError(t, err)

        // Seed test data
        GenerateTestData(db, storageManager)

        // Init repos, services, handlers
        socketManager := socket.CreateSocketManager(authManager)

        statusMessageNamespace := socket.CreateOutputNamespace[statusMessage.StatusMessage](
                socketManager, false, false, nil, "status-messages",
        )

        userRepo := user.CreateRepository(db)
        userService := user.CreateService(userRepo, authManager)
        userHandler := user.CreateHandler(userService)

        devicesHandler := device.CreateHandler(devicesService)

        schemaHandler := schema.CreateHandler(schemaService)

        collectionRepo := collection.CreateRepository(db)
        collectionService := collection.CreateService(collectionRepo, userRepo)
        collectionHandler := collection.CreateHandler(collectionService)

        topologyRepository := topology.CreateRepository(db)
        topologyService := topology.CreateService(
                topologyRepository, userRepo, collectionRepo,
                storageManager, schemaService.Get(),
        )
        topologyHandler := topology.CreateHandler(topologyService)

        labRepository := lab.CreateRepository(db)
        labService := lab.CreateService(
                cfg, labRepository, userRepo, topologyRepository, topologyService,
                storageManager, socketManager, statusMessageNamespace,
        )
        labHandler := lab.CreateHandler(labService)

        addAuthenticatedUsers(authManager)

        authManager.RegisterTestUser(auth.AuthenticatedUser{
                UserId:      auth.NativeUserID,
                IsAdmin:     true,
                Collections: []string{"hidden-group", "fs25-cldinf", "fs25-nisec", "hs25-cn1", "hs25-cn2"},
        })

        // Setup Gin + register routes with real middleware
        router := gin.Default()
        collection.RegisterRoutes(router, collectionHandler, authManager)
        device.RegisterRoutes(router, devicesHandler, authManager)
        topology.RegisterRoutes(router, topologyHandler, authManager)
        schema.RegisterRoutes(router, schemaHandler)
        user.RegisterRoutes(router, userHandler)
        lab.RegisterRoutes(router, labHandler, authManager)
        return router, authManager, db
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import "flag"

type CommandLineArguments struct {
        ConfigFile       *string
        UseLocalDatabase *bool
        DevelopmentMode  *bool
}

func ParseArguments() *CommandLineArguments <span class="cov0" title="0">{
        cmdArgs := &amp;CommandLineArguments{
                flag.String("config", "./config.default.yml", "Path to the configuration file"),
                flag.Bool("sqlite", false, "Whether to use the local SQLite database"),
                flag.Bool("dev", false, "Whether to start Antimony in development mode"),
        }
        flag.Parse()

        return cmdArgs
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package utils

import (
        "errors"
        "net/http"
)

type ErrorResponse struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

type OkResponse[T any] struct {
        Payload T `json:"payload"`
}

func CreateOkResponse[T any](obj T) (int, OkResponse[T]) <span class="cov8" title="1">{
        return http.StatusOK, OkResponse[T]{Payload: obj}
}</span>

func CreateErrorResponse(err error) (int, ErrorResponse) <span class="cov8" title="1">{
        switch </span>{
        case errors.Is(err, ErrorUuidNotFound):<span class="cov8" title="1">
                return http.StatusNotFound, ErrorResponse{Code: -1, Message: err.Error()}</span>
        case errors.Is(err, ErrorInvalidCredentials):<span class="cov8" title="1">
                return http.StatusBadRequest, ErrorResponse{Code: 1001, Message: err.Error()}</span>
        case errors.Is(err, ErrorCollectionExists):<span class="cov8" title="1">
                return http.StatusBadRequest, ErrorResponse{Code: 2001, Message: err.Error()}</span>
        case errors.Is(err, ErrorTopologyExists):<span class="cov8" title="1">
                return http.StatusBadRequest, ErrorResponse{Code: 3001, Message: err.Error()}</span>
        case errors.Is(err, ErrorInvalidTopology):<span class="cov8" title="1">
                return http.StatusBadRequest, ErrorResponse{Code: 3003, Message: err.Error()}</span>
        case errors.Is(err, ErrorBindFileExists):<span class="cov8" title="1">
                return http.StatusBadRequest, ErrorResponse{Code: 4001, Message: err.Error()}</span>
        case errors.Is(err, ErrorInvalidBindFilePath):<span class="cov8" title="1">
                return http.StatusBadRequest, ErrorResponse{Code: 4002, Message: err.Error()}</span>
        case errors.Is(err, ErrorDatabaseError):<span class="cov0" title="0">
                return http.StatusInternalServerError, ErrorResponse{Code: 500, Message: err.Error()}</span>
        // Permission / Access errors
        case errors.Is(err, ErrorUnauthorized),
                errors.Is(err, ErrorOpenIDAuthDisabledError),
                errors.Is(err, ErrorNativeAuthDisabledError):<span class="cov8" title="1">
                return http.StatusUnauthorized, ErrorResponse{Code: 401, Message: err.Error()}</span>
        case errors.Is(err, ErrorTokenInvalid):<span class="cov8" title="1">
                return 498, ErrorResponse{Code: 498, Message: err.Error()}</span>
        case errors.Is(err, ErrorForbidden),
                errors.Is(err, ErrorNoAccessToLab),
                errors.Is(err, ErrorNoWriteAccessToLab),
                errors.Is(err, ErrorNoWriteAccessToBindFile),
                errors.Is(err, ErrorNoWriteAccessToTopology),
                errors.Is(err, ErrorNoWriteAccessToCollection),
                errors.Is(err, ErrorNoDeployAccessToCollection),
                errors.Is(err, ErrorNoDeployAccessToLab),
                errors.Is(err, ErrorNoPermissionToCreateCollections):<span class="cov8" title="1">
                return http.StatusForbidden, ErrorResponse{Code: 403, Message: err.Error()}</span>
        }

        <span class="cov8" title="1">return http.StatusInternalServerError, ErrorResponse{Code: -1, Message: err.Error()}</span>
}

func CreateValidationError(err error) (int, ErrorResponse) <span class="cov8" title="1">{
        return http.StatusUnprocessableEntity, ErrorResponse{Code: 422, Message: err.Error()}
}</span>

func CreateSocketErrorResponse(err error) ErrorResponse <span class="cov8" title="1">{
        switch </span>{
        case errors.Is(err, ErrorContainerlab):<span class="cov0" title="0">
                return ErrorResponse{Code: 5001, Message: err.Error()}</span>
        case errors.Is(err, ErrorLabIsDeploying):<span class="cov0" title="0">
                return ErrorResponse{Code: 5002, Message: err.Error()}</span>
        case errors.Is(err, ErrorLabNotRunning):<span class="cov8" title="1">
                return ErrorResponse{Code: 5003, Message: err.Error()}</span>
        case errors.Is(err, ErrorNodeNotRunning):<span class="cov0" title="0">
                return ErrorResponse{Code: 5004, Message: err.Error()}</span>
        case errors.Is(err, ErrorUuidNotFound):<span class="cov0" title="0">
                return ErrorResponse{Code: 5005, Message: err.Error()}</span>
        case errors.Is(err, ErrorNodeNotFound):<span class="cov8" title="1">
                return ErrorResponse{Code: 5006, Message: err.Error()}</span>
        case errors.Is(err, ErrorShellNotFound):<span class="cov8" title="1">
                return ErrorResponse{Code: 5007, Message: err.Error()}</span>
        case errors.Is(err, ErrorShellLimitReached):<span class="cov0" title="0">
                return ErrorResponse{Code: 5008, Message: err.Error()}</span>
        case errors.Is(err, ErrorInvalidSocketRequest):<span class="cov8" title="1">
                return ErrorResponse{Code: 5422, Message: err.Error()}</span>
        // Permission / Access errors
        case errors.Is(err, ErrorNoDeployAccessToCollection):<span class="cov0" title="0"></span>
        case errors.Is(err, ErrorNoDestroyAccessToLab):<span class="cov0" title="0"></span>
        case errors.Is(err, ErrorNoAccessToShell):<span class="cov0" title="0"></span>
        case errors.Is(err, ErrorNoAccessToLab):<span class="cov0" title="0">
                return ErrorResponse{Code: 5403, Message: err.Error()}</span>
        }

        <span class="cov8" title="1">return ErrorResponse{Code: -1, Message: err.Error()}</span>
}

func CreateSocketOkResponse[T any](obj T) OkResponse[T] <span class="cov8" title="1">{
        return OkResponse[T]{Payload: obj}
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import (
        "slices"
        "sort"
        "sync"
        "time"
)

type (
        Schedule[T any] interface {
                Schedule(item *T)
                Reschedule(item *T)
                IsScheduled(key string) bool

                Remove(key string)

                TryPop() *T
        }

        schedule[T any] struct {
                schedule    []*T
                scheduleMap map[string]*T

                mutex *sync.Mutex

                keyGetter  func(T) string
                timeGetter func(T) *time.Time
        }
)

func CreateSchedule[T any](keyGetter func(T) string, timeGetter func(T) *time.Time) Schedule[T] <span class="cov8" title="1">{
        schedule := &amp;schedule[T]{
                schedule:    make([]*T, 0),
                scheduleMap: make(map[string]*T),
                mutex:       &amp;sync.Mutex{},
                keyGetter:   keyGetter,
                timeGetter:  timeGetter,
        }

        return schedule
}</span>

func (s *schedule[T]) Schedule(item *T) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        // Skip scheduling if the item's time is nil
        if s.timeGetter(*item) == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">s.insert(s.keyGetter(*item), item)</span>
}

func (s *schedule[T]) Reschedule(item *T) <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if _, isScheduled := s.scheduleMap[s.keyGetter(*item)]; isScheduled </span><span class="cov0" title="0">{
                s.remove(s.keyGetter(*item))
        }</span>

        <span class="cov8" title="1">s.insert(s.keyGetter(*item), item)</span>
}

func (s *schedule[T]) IsScheduled(key string) bool <span class="cov8" title="1">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        return s.has(key)
}</span>

func (s *schedule[T]) Remove(key string) <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        s.remove(key)
}</span>

func (s *schedule[T]) TryPop() *T <span class="cov0" title="0">{
        s.mutex.Lock()
        defer s.mutex.Unlock()

        if len(s.schedule) &gt; 0 &amp;&amp; s.timeGetter(*s.schedule[0]).Unix() &lt;= time.Now().Unix() </span><span class="cov0" title="0">{
                item := s.schedule[0]

                s.schedule = s.schedule[1:]
                delete(s.scheduleMap, s.keyGetter(*item))

                return item
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *schedule[T]) has(key string) bool <span class="cov8" title="1">{
        _, ok := s.scheduleMap[key]

        return ok
}</span>

func (s *schedule[T]) remove(key string) <span class="cov0" title="0">{

        if item, isScheduled := s.scheduleMap[key]; isScheduled </span><span class="cov0" title="0">{
                delete(s.scheduleMap, key)
                itemIndex := slices.Index(s.schedule, item)
                s.schedule = append(s.schedule[:itemIndex], s.schedule[itemIndex+1:]...)
        }</span>
}

func (s *schedule[T]) insert(key string, item *T) <span class="cov8" title="1">{
        itemTime := s.timeGetter(*item).Unix()
        insertIndex := sort.Search(len(s.schedule), func(i int) bool </span><span class="cov0" title="0">{
                return s.timeGetter(*s.schedule[i]).Unix() &gt;= itemTime
        }</span>)

        <span class="cov8" title="1">if insertIndex == len(s.schedule) </span><span class="cov8" title="1">{
                s.schedule = append(s.schedule, item)
                s.scheduleMap[key] = item
                return
        }</span>

        <span class="cov0" title="0">s.schedule = append(s.schedule[:insertIndex+1], s.schedule[insertIndex:]...)
        s.schedule[insertIndex] = item
        s.scheduleMap[key] = item</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "github.com/google/uuid"
        "os"
)

func GenerateUuid() string <span class="cov8" title="1">{
        uuid1, err := uuid.NewUUID()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to generate UUID")</span>
        }

        <span class="cov8" title="1">return uuid1.String()</span>
}

func IsDirectoryWritable(path string) bool <span class="cov8" title="1">{
        info, err := os.Stat(path)

        // TODO: Proper access check implementation
        return err == nil &amp;&amp; info.IsDir() &amp;&amp; info.Mode().Perm()&amp;(1&lt;&lt;(uint(7))) != 0
}</span>

func StringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

func NounCounter(noun string, count int) string <span class="cov0" title="0">{
        if count == 1 </span><span class="cov0" title="0">{
                return noun
        }</span>
        <span class="cov0" title="0">return noun + "s"</span>
}

func GetItemsFromList[T any](list []T, limit int, offset int) []T <span class="cov0" title="0">{
        if offset &gt;= len(list) </span><span class="cov0" title="0">{
                return make([]T, 0)
        }</span>

        <span class="cov0" title="0">end := offset + limit
        if end &gt; len(list) </span><span class="cov0" title="0">{
                end = len(list)
        }</span>

        <span class="cov0" title="0">return list[offset:end]</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
